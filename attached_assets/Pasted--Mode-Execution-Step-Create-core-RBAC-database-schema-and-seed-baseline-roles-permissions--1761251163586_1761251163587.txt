[Mode: Execution]

**Step:** Create core RBAC database schema and seed baseline roles/permissions (Drizzle + Supabase).

**Why it matters:** This gives the ERP shell a single source of truth for access control so the Task module (and every future module) can call `hasPermission()` instead of hard-coding role checks, avoiding rework later.  

**Inputs needed:**

* Your Replit repo (linked).
* Drizzle already set up for PostgreSQL (as in your API app).
* Supabase Auth enabled (users live in `auth.users`).

**Command:**

1. In your API app, add a Drizzle schema file for RBAC (adjust pathing if your repo differs).

```bash
mkdir -p apps/api/src/db/schema
```

2. Create `apps/api/src/db/schema/rbac.ts`:

```ts
// apps/api/src/db/schema/rbac.ts
import { pgTable, varchar, timestamp, uuid, primaryKey } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// 1) Roles
export const roles = pgTable("roles", {
  id: varchar("id", { length: 64 }).primaryKey(), // e.g. "admin", "project_manager"
  label: varchar("label", { length: 120 }).notNull(),
  createdAt: timestamp("created_at", { mode: "date", withTimezone: true }).defaultNow(),
});

// 2) Permissions (string namespace like "tasks:create")
export const permissions = pgTable("permissions", {
  id: varchar("id", { length: 128 }).primaryKey(), // e.g. "projects:read"
  label: varchar("label", { length: 160 }).notNull(),
  createdAt: timestamp("created_at", { mode: "date", withTimezone: true }).defaultNow(),
});

// 3) Role-Permissions (many-to-many)
export const rolePermissions = pgTable("role_permissions", {
  roleId: varchar("role_id", { length: 64 }).notNull(),
  permissionId: varchar("permission_id", { length: 128 }).notNull(),
  createdAt: timestamp("created_at", { mode: "date", withTimezone: true }).defaultNow(),
}, (t) => ({
  pk: primaryKey({ columns: [t.roleId, t.permissionId] })
}));

// 4) User-Roles (users from Supabase auth.users)
export const userRoles = pgTable("user_roles", {
  userId: uuid("user_id").notNull(),            // references auth.users.id (Supabase schema)
  roleId: varchar("role_id", { length: 64 }).notNull(),
  // Optional: time-limited delegation
  expiresAt: timestamp("expires_at", { mode: "date", withTimezone: true }),
  createdAt: timestamp("created_at", { mode: "date", withTimezone: true }).defaultNow(),
}, (t) => ({
  pk: primaryKey({ columns: [t.userId, t.roleId] })
}));

// (Optional) Simple audit log for RBAC actions
export const rbacAuditLogs = pgTable("rbac_audit_logs", {
  id: uuid("id").defaultRandom().primaryKey(),
  actorUserId: uuid("actor_user_id").notNull(),
  action: varchar("action", { length: 64 }).notNull(), // e.g. "assign_role", "revoke_role", "grant_permission"
  subject: varchar("subject", { length: 200 }).notNull(), // e.g. role/user/permission id
  meta: varchar("meta", { length: 2000 }), // JSON string if desired
  createdAt: timestamp("created_at", { mode: "date", withTimezone: true }).defaultNow(),
});

// Relations (optional, helps with Drizzle type inference)
export const rolesRelations = relations(roles, ({ many }) => ({
  rolePermissions: many(rolePermissions),
  userRoles: many(userRoles),
}));
export const permissionsRelations = relations(permissions, ({ many }) => ({
  rolePermissions: many(rolePermissions),
}));
```

3. Add a seed script `apps/api/src/db/seeds/rbacSeed.ts` (run once):

```ts
// apps/api/src/db/seeds/rbacSeed.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { Client } from "pg";
import { roles, permissions, rolePermissions } from "../schema/rbac";

// Core permission set (expand later module-by-module)
const PERMS = [
  "projects:read","projects:create","projects:update","projects:delete",
  "tasks:read","tasks:create","tasks:update","tasks:delete",
  "attachments:upload","attachments:delete",
  "comments:write","comments:delete",
  "project_requests:submit","project_requests:approve",
  "rbac:manage"
] as const;

const ROLES = [
  { id: "admin", label: "Admin" },
  { id: "project_manager", label: "Project Manager" },
  { id: "contributor", label: "Contributor" },
  { id: "viewer", label: "Viewer" },
  { id: "client_guest", label: "Client Guest" },
];

const MAP: Record<string, string[]> = {
  admin: [...PERMS],
  project_manager: [
    "projects:read","projects:create","projects:update",
    "tasks:read","tasks:create","tasks:update","attachments:upload","comments:write","project_requests:approve"
  ],
  contributor: [
    "projects:read","project_requests:submit",
    "tasks:read","tasks:create","tasks:update",
    "attachments:upload","comments:write"
  ],
  viewer: ["projects:read","tasks:read"],
  client_guest: ["projects:read","tasks:read"], // narrow in UI by project-sharing scope later
};

async function main() {
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();
  const db = drizzle(client);

  // upsert roles
  for (const r of ROLES) {
    await db.insert(roles).values(r).onConflictDoNothing();
  }

  // upsert permissions
  for (const p of PERMS) {
    await db.insert(permissions).values({ id: p, label: p }).onConflictDoNothing();
  }

  // link role->permissions
  for (const r of ROLES) {
    const perms = MAP[r.id] ?? [];
    for (const p of perms) {
      await db.insert(rolePermissions).values({ roleId: r.id, permissionId: p }).onConflictDoNothing();
    }
  }

  await client.end();
  // eslint-disable-next-line no-console
  console.log("✅ RBAC seed complete");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

4. Wire the seed to an npm script and run migrations + seed:

```bash
# package.json (apps/api) add:
# "db:seed:rbac": "tsx src/db/seeds/rbacSeed.ts"

cd apps/api
npm run db:generate || true   # if you use drizzle-kit generate
npm run db:push || true       # or your project's migration command
npm run db:seed:rbac
```

5. (Optional but recommended now) Add a Postgres view that resolves a user’s *effective* permissions based on current time (handles time-limited roles cleanly):

```sql
-- apps/api/sql/rbac_effective_permissions.sql
create or replace view rbac_effective_permissions as
select
  ur.user_id,
  rp.permission_id
from user_roles ur
join role_permissions rp on rp.role_id = ur.role_id
where ur.expires_at is null or ur.expires_at > now();
```

You can query this view in middleware to build a fast `Set<string>` for the JWT/session.

**Success check:**

* Run a quick SQL probe (via your DB console or a tiny endpoint) to confirm seeds:

```sql
select * from roles order by id;
select * from permissions order by id limit 5;
select role_id, count(*) perms from role_permissions group by role_id order by role_id;
```

Expected: 5 roles present; `admin` mapped to all permissions; others mapped as defined.

**Next:** wait for user.

---

Tiny training nugget (why this order): building the RBAC spine now means your Task features won’t scatter “if(user.role===…)” debris all over the codebase. The modules stay role-agnostic and simply ask the central checker—exactly what your research argues for: foundation first, then features.  

When you reply “Seeded” (or paste any errors), I’ll give Step 2: add `requirePermission()` middleware + `usePermissions()` hook signatures so UI and API read from the same truth with zero duplication.
