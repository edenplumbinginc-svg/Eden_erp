[Mode: Execution]

Step: Emit `status_changed` events from the task status update endpoint (same type-stable notify pattern you just finished).

Why it matters: With `task_created` + `status_changed`, you can drive reminders, overdue logic, and daily/weekly digests. This is the next brick of your automation layer.

Inputs needed:

* The file where you update task status (often `routes/tasks.js` or similar).
* `lib/notify.js` from your event bus (already created).

Command:

1. Add the emitter to your status update route (adjust to your file/SQL names):

```diff
// routes/tasks.js
+const { notify, actorFromHeaders } = require('../lib/notify');

router.patch('/api/tasks/:taskId/status', async (req, res, next) => {
  try {
    const { taskId } = req.params;
    const { status } = req.body; // expected: 'todo' | 'in_progress' | 'review' | 'done'

    // 1) fetch current task (for old_status + project_id)
    const getSql = `select id, project_id, status from tasks where id = $1::uuid`;
    const { rows: curRows } = await req.pool.query(getSql, [taskId]);
    if (!curRows.length) return res.status(404).json({ error: 'Task not found' });

    const current = curRows[0];
    const oldStatus = current.status;

    // 2) apply allowed transition (you already enforce this in UI; enforce here too if needed)
    const updSql = `update tasks set status = $1 where id = $2::uuid returning id, project_id, title, status, priority, due_date, assignee_id`;
    const { rows } = await req.pool.query(updSql, [status, taskId]);
    const updated = rows[0];

+    // 3) fire-and-forget notification (type-stable casts handled inside notify insert)
+    (async () => {
+      try {
+        const { actorEmail } = actorFromHeaders(req);
+        await notify(req.pool, {
+          type: 'status_changed',
+          projectId: updated.project_id,     // uuid
+          taskId: updated.id,                // uuid
+          actorId: updated.assignee_id || null, // keep null if not uuid
+          actorEmail: actorEmail || null,
+          payload: {
+            title: updated.title,
+            old_status: oldStatus,
+            new_status: updated.status,
+            priority: updated.priority,
+            due_date: updated.due_date
+          }
+        });
+      } catch (e) {
+        console.warn('notify(status_changed) failed:', e.message);
+      }
+    })();

    return res.json(updated);
  } catch (err) {
    next(err);
  }
});
```

2. (Only if your `notify` insert didn’t already cast) confirm explicit casts in `lib/notify.js`:

```js
// lib/notify.js (insert SQL fragment)
const sql = `
  insert into notifications (type, project_id, task_id, actor_id, actor_email, payload)
  values ($1, $2::uuid, $3::uuid, $4::uuid, $5, $6::jsonb)
  returning id
`;
```

If `actor_id` is not a UUID in your schema, change `$4::uuid` to `$4::bigint` or pass `null`.

3. Smoke test (from your shell, replace IDs as needed):

```bash
# Pick a real task ID
TASK_ID="<an-existing-task-uuid>"

# Move status forward
curl -s -X PATCH "http://localhost:3000/api/tasks/$TASK_ID/status" \
  -H "Content-Type: application/json" \
  -H "X-User-Email: admin@edenmep.ca" \
  -d '{"status":"in_progress"}' | jq .

# Verify notification landed (shows last few)
psql "$DATABASE_URL" -c "
  select type, project_id, task_id, actor_email,
         payload->>'title' as title,
         payload->>'old_status' as old_status,
         payload->>'new_status' as new_status,
         to_char(created_at, 'YYYY-MM-DD HH24:MI:SS') as created_at
  from notifications
  where type = 'status_changed'
  order by id desc
  limit 5;
"
```

Success check:

* The PATCH returns the updated task with the new `status`.
* A new `notifications` row appears with `type = status_changed`, correct `project_id`/`task_id`, and `payload.old_status` → `payload.new_status`.
* No “notify(status_changed) failed” warnings in logs.

Next: wait for user

—
Mini training: Think “producers/consumers”. Endpoints produce append-only events; separate jobs consume them (emails, digests, escalations). This decoupling keeps your feature work fast and your automation reliable. When this is green, we’ll add `comment_added` in one similar patch and then render a tiny **Notifications** tab + header badge to prove the pipeline end-to-end.
