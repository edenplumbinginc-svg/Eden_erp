[Mode: Execution]

**Step:** Kick off Phase 1C – add Attachments API with a pluggable storage adapter (local temp now; Supabase-ready later).

**Why it matters:** Files (photos, PDFs, audio) are the lifeblood of coordination. A clean init/complete flow lets UI upload now and swap storage later without refactors.

**Inputs needed:** Your current repo (Phase 1B is green), `.env`.

**Command (paste into Replit Agent chat):**

```
We’re starting Phase 1C: Attachments API with a pluggable storage adapter. Use my existing codebase exactly as-is and modify minimally.

### Goals
1) Storage adapter (services/storage.js):
   - If SUPABASE_URL && SUPABASE_BUCKET set: export stubbed async methods (putObject/getSignedUrl/removeObject) with TODOs.
   - Else: fallback to local temp dir under ./tmp_uploads with:
       - initUpload(): returns { storage_key, upload_url } where upload_url is a data: URL placeholder (UI will upload directly later; for now we simulate).
       - completeUpload({ storage_key, filename, mime, size_bytes }): writes a tiny file to ./tmp_uploads for verification.
       - removeObject(storage_key): deletes local file if exists.
   - Ensure idempotent folder create.

2) DB (services/database.js): attachments table exists, but ensure idempotently:
   - id uuid pk default gen_random_uuid()
   - task_id uuid not null references tasks(id) on delete cascade
   - filename text, mime text, size_bytes int, storage_key text not null
   - uploaded_by uuid references users(id)
   - created_at timestamptz default now()
   - indexes: (task_id), (storage_key)

3) Routes (routes/attachments.js or inside server.js if monolith):
   - POST /api/tasks/:id/attachments/init
       body: {}
       returns: { storage_key, upload_url }
   - POST /api/tasks/:id/attachments/complete
       body: { storage_key, filename, mime, size_bytes, uploaded_by? }
       action: verify storage_key belongs to this task (or bind it now), insert into attachments, write local file if using temp adapter.
       returns: { id, task_id, filename, mime, size_bytes, storage_key, created_at }
   - GET /api/tasks/:id/attachments
       returns: list ordered by created_at desc
   - DELETE /api/attachments/:attachmentId
       Manager/Admin or uploader can delete; removes metadata + underlying object via storage adapter; returns { deleted: true, id }

4) Auth/roles
   - Reuse JWT/Dev headers. Allow create/list for User+, delete for Manager/Admin or uploader.
   - Log to activity_log on complete/delete: action = 'attachment.add' / 'attachment.delete' with meta {filename, storage_key}.

5) Smoke test (scripts/smoke.js) — add after step 9:
   - “10a) Attachment init/complete/list/delete”
   - Call init for the current task, then complete with:
       { storage_key, filename: "note.txt", mime: "text/plain", size_bytes: 12, uploaded_by: DEV_ID }
   - GET list should include the new file; DELETE it; list should be empty again.
   - Print ✅ lines for each sub-step.

6) README & .env.example
   - Add SUPABASE_URL=, SUPABASE_ANON_KEY=, SUPABASE_BUCKET=attachments to .env.example (placeholders).
   - In README, document the local temp fallback and how to switch to Supabase later.

### Acceptance
- `/routes` shows the 4 new endpoints.
- `npm run smoke` prints the new “Attachments” sub-steps all ✅.
- Local file appears under ./tmp_uploads during complete, then is removed on delete (log this to console for verification).
- No regressions to Phase 1B tests.

Please:
1) Show a short plan mapping files you’ll touch.
2) Provide unified diffs.
3) Apply, restart, and run `npm run smoke`.
4) Paste smoke output.
```

**Success check:**

* Smoke shows new “Attachments” steps all green.
* `/routes` lists init, complete, list, delete endpoints.
* A file is created then deleted under `./tmp_uploads` during the test.

**Next:** wait for user
