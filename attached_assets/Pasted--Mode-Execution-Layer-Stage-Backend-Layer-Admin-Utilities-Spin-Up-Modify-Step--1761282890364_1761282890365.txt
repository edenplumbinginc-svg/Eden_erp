[Mode: Execution]

**Layer/Stage:** Backend Layer → Admin Utilities | Spin-Up → Modify
**Step:** Add a secure **User Resolver** endpoint (email → Supabase UUID) gated by `admin:manage`, then wire it into the Admin RBAC UI so ops can paste an email instead of a UUID.

**Why it matters:** Admins work with emails, not UUIDs. Resolving on the server (with the service key) keeps secrets off the client and speeds role assignment.

**Inputs needed:**

* `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY` already set (backend only).
* Existing admin endpoints live.

**Command (backend):**

1. Create Supabase admin client:

```ts
// apps/api/src/lib/supabaseAdmin.ts
import { createClient } from "@supabase/supabase-js";
export const supabaseAdmin = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // server-only
  { auth: { persistSession: false, autoRefreshToken: false } }
);
```

2. Add resolver route:

```ts
// apps/api/src/routes/adminUserResolve.ts
import { Router } from "express";
import { requireAuth, requirePerm } from "../middleware/auth";
import { supabaseAdmin } from "../lib/supabaseAdmin";

const router = Router();

router.get(
  "/admin/user-lookup",
  requireAuth,
  requirePerm("admin:manage"),
  async (req, res) => {
    const email = (req.query.email as string)?.trim().toLowerCase();
    if (!email) return res.status(400).json({ error: "EMAIL_REQUIRED" });

    // Supabase: list users by email (exact match)
    const { data, error } = await supabaseAdmin.auth.admin.listUsers({
      page: 1, perPage: 200,
    });

    if (error) return res.status(500).json({ error: "SUPABASE_ADMIN_ERROR" });

    const match = (data?.users || []).find(u =>
      u.email?.toLowerCase() === email || u.user_metadata?.email?.toLowerCase() === email
    );

    if (!match) return res.status(404).json({ error: "USER_NOT_FOUND" });

    res.json({
      id: match.id,
      email: match.email,
      created_at: match.created_at,
      identities: (match.identities || []).map(i => ({ provider: i.provider, identity_id: i.identity_id })),
    });
  }
);

export default router;
```

3. Wire it up:

```ts
// apps/api/src/app.ts (or server bootstrap)
import adminUserResolve from "./routes/adminUserResolve";
app.use("/api", adminUserResolve);
```

**Success check (terminal):**

```bash
JWT=<admin_jwt_with_admin_manage>
curl -s "http://localhost:3000/api/admin/user-lookup?email=ops@edenmep.ca" \
  -H "Authorization: Bearer $JWT" | jq .
# expect: { id: "uuid...", email: "ops@edenmep.ca", ... }
```

---

**Layer/Stage:** Frontend Layer → Admin UI Shell | Spin-Up → Modify
**Step:** Update **RBAC Admin Page** to resolve email → UUID, populate, and toggle roles.

**Command (frontend):**

1. Client call:

```js
// apps/coordination_ui/src/services/adminRbac.js
export async function lookupUserByEmail(email) {
  const r = await authFetch(`/api/admin/user-lookup?email=${encodeURIComponent(email)}`);
  if (!r.ok) throw new Error("Lookup failed");
  return r.json(); // { id, email, ... }
}
```

2. Page enhancement (add “Resolve by Email”):

```jsx
// apps/coordination_ui/src/pages/AdminRbacPage.jsx
import { lookupUserByEmail } from "../services/adminRbac";

export default function AdminRbacPage() {
  // ...existing state
  const [email, setEmail] = useState("");

  async function resolveEmail() {
    setErr(null); setNote(""); setLoading(true);
    try {
      const u = await lookupUserByEmail(email);
      setUserId(u.id);
      setNote(`Resolved: ${u.email} → ${u.id}`);
      await loadUser(); // reuse existing loader (uses userId)
    } catch (e) {
      setErr("User not found for that email.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <PermissionGate perm="admin:manage">
      <div className="p-4 max-w-3xl mx-auto space-y-4">
        <h1 className="text-xl font-semibold">RBAC – Role Management</h1>

        {/* Resolve by Email */}
        <div className="space-y-2">
          <label className="text-sm font-medium">Resolve by Email</label>
          <div className="flex gap-2">
            <input className="flex-1 border rounded p-2" placeholder="user@edenmep.ca"
                   value={email} onChange={e=>setEmail(e.target.value)}/>
            <button className="border rounded px-3 py-1 text-sm"
                    onClick={resolveEmail} disabled={!email || loading}>
              Resolve
            </button>
          </div>
          {note && <div className="text-slate-600 text-sm">{note}</div>}
        </div>

        {/* Existing UUID input + roles table remain unchanged */}
        {/* ... */}
      </div>
    </PermissionGate>
  );
}
```

**Success check (UI):**

* Visit `/admin/rbac` as an admin.
* Enter an email, click **Resolve** → UUID fills, roles load.
* Toggle checkboxes to assign/remove; changes reflect immediately.

---

**Layer/Stage:** Backend Layer → Admin Utilities | Spin-Up → Modify
**Step (bonus quality):** Add **role templates** endpoint to apply a preset in one click.

**Command (backend):**

```ts
// apps/api/src/routes/adminRoleTemplates.ts
import { Router } from "express";
import { requireAuth, requirePerm } from "../middleware/auth";
import { db } from "../db";
import { roles, userRoles } from "../db/schema/rbac";
import { eq, inArray } from "drizzle-orm";

const router = Router();

// define server-side templates (edit to match your slugs)
const templates: Record<string, string[]> = {
  operations: ["ops", "viewer"],
  contributor: ["contributor", "viewer"],
  manager: ["pm", "viewer"],
};

router.get("/admin/role-templates", requireAuth, requirePerm("admin:manage"), (_req, res) => {
  res.json({ templates: Object.keys(templates) });
});

router.post("/admin/users/:userId/apply-template/:template", requireAuth, requirePerm("admin:manage"), async (req, res) => {
  const { userId, template } = req.params;
  const slugs = templates[template];
  if (!slugs) return res.status(404).json({ error: "TEMPLATE_NOT_FOUND" });

  const rs = await db.select().from(roles).where(inArray(roles.slug, slugs));
  if (rs.length === 0) return res.status(404).json({ error: "ROLES_NOT_FOUND" });

  await db.insert(userRoles)
    .values(rs.map(r => ({ userId: userId as any, roleId: r.id })))
    .onConflictDoNothing();

  res.status(204).end();
});

export default router;
```

Wire it:

```ts
// apps/api/src/app.ts
import adminRoleTemplates from "./routes/adminRoleTemplates";
app.use("/api", adminRoleTemplates);
```

**Frontend quick add (optional button beside email/UUID):**

```jsx
// In AdminRbacPage.jsx
async function applyTemplate(name) {
  setErr(null); setLoading(true);
  try {
    const r = await authFetch(`/api/admin/users/${userId}/apply-template/${name}`, { method: "POST" });
    if (!r.ok && r.status !== 204) throw new Error("Template apply failed");
    await loadUser(); // refresh roles
  } catch {
    setErr("Template apply failed.");
  } finally {
    setLoading(false);
  }
}
// Render buttons:
<div className="flex flex-wrap gap-2">
  {["operations","contributor","manager"].map(t => (
    <button key={t} className="border rounded px-2 py-1 text-xs" disabled={!userId || loading}
            onClick={()=>applyTemplate(t)}>
      Apply: {t}
    </button>
  ))}
</div>
```

---

### Progress Telemetry

* **Backend Layer (Admin Utilities):** Spin-Up → Modify ✅ → Test
* **Frontend Layer (Admin UI Shell):** Spin-Up → Modify ✅ → Test
* **Integration Layer:** Transition → Test (email→UUID resolve + role toggles + templates)

**Next:** wait for user.
Once you confirm email resolution and role toggles work on `/admin/rbac`, I’ll ship a **tiny audit log sink** (DB table + writer) so every role change is persisted (actor, subject, role, action, timestamp) for compliance-grade traceability.
