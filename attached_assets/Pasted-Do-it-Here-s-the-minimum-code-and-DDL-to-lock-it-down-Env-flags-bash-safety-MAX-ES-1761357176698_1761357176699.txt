Do it. Here’s the minimum code and DDL to lock it down.

## Env flags

```bash
# safety
MAX_ESC_LEVEL=7
ESC_SNOOZE_MIN=30
ESC_PAUSE_CRON=0 22 * * *        # pause 22:00 daily, example
ESC_DRY_RUN=false

# timing
ESC_TICK_MS=60000
ESC_CRIT_ACK_MIN=5
ESC_WARN_ACK_MIN=15

# feature flag + canary
ESCALATION_WORKER_ENABLED=true
ESCALATION_V1=true
ESC_CANARY_PCT=10

# security
OPS_HMAC_SECRET=change_me
OPS_ADMIN_ROLE=ops_admin
```

## SQL: events table + indices + next_due_at

```sql
CREATE TABLE IF NOT EXISTS escalation_events (
  id bigserial PRIMARY KEY,
  incident_key text NOT NULL,
  level int NOT NULL,
  unique_hash text NOT NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE incidents
  ADD COLUMN IF NOT EXISTS next_due_at timestamptz
  GENERATED ALWAYS AS (
    CASE
      WHEN acknowledged_at IS NOT NULL THEN NULL
      ELSE first_seen
           + (CASE severity WHEN 'critical' THEN (ESC_CRIT_ACK_MIN || ' minutes')::interval
                            ELSE (ESC_WARN_ACK_MIN || ' minutes')::interval
              END) * (escalation_level + 1)
    END
  ) STORED;

CREATE INDEX IF NOT EXISTS ix_inc_ack ON incidents (acknowledged_at);
CREATE INDEX IF NOT EXISTS ix_inc_sev_level ON incidents (severity, escalation_level);
CREATE INDEX IF NOT EXISTS ix_inc_due ON incidents (next_due_at) WHERE acknowledged_at IS NULL;
```

## Worker query (skip scans)

```sql
-- due now and not past max level, respect snooze
WITH due AS (
  SELECT *
  FROM incidents
  WHERE acknowledged_at IS NULL
    AND now() >= next_due_at
    AND escalation_level < :MAX_ESC_LEVEL
    AND (last_escalated_at IS NULL OR now() - last_escalated_at >= (:ESC_SNOOZE_MIN || ' minutes')::interval)
)
SELECT * FROM due;
```

## Node/Express: RBAC + HMAC + rate limit

```js
// rbac.js
export function requireOpsAdmin(req, res, next) {
  if (!req.user?.roles?.includes(process.env.OPS_ADMIN_ROLE)) return res.sendStatus(403);
  next();
}

// hmac.js
import crypto from "crypto";
export function verifyHmac(req, res, next) {
  const sig = req.header("X-Signature");
  const body = JSON.stringify(req.body || {});
  const h = crypto.createHmac("sha256", process.env.OPS_HMAC_SECRET).update(body).digest("hex");
  if (sig !== h) return res.sendStatus(401);
  next();
}

// rate-limit.js (in-memory, swap to Redis in prod)
const buckets = new Map();
export function rateLimit(keyFn, maxPerMin=10) {
  return (req, res, next) => {
    const key = keyFn(req);
    const now = Date.now();
    const w = buckets.get(key) || [];
    const w2 = w.filter(t => now - t < 60000);
    if (w2.length >= maxPerMin) return res.sendStatus(429);
    w2.push(now); buckets.set(key, w2);
    next();
  };
}
```

## Secure test endpoint

```js
import { requireOpsAdmin } from "./rbac.js";
import { verifyHmac } from "./hmac.js";
import { rateLimit } from "./rate-limit.js";

app.post(
  "/ops/escalation/tick",
  requireOpsAdmin,
  verifyHmac,
  rateLimit(req=>`tick:${req.user?.id||req.ip}`, 10),
  async (req, res) => {
    const count = await escalationTick({ dryRun: process.env.ESC_DRY_RUN === "true" });
    res.json({ escalations: count });
  }
);
```

## Idempotency + Slack de-dupe

```js
import crypto from "crypto";

function eventHash(incidentKey, level) {
  return crypto.createHash("sha256").update(`${incidentKey}|${level}`).digest("hex");
}

async function recordOnce(client, incidentKey, level) {
  const h = eventHash(incidentKey, level);
  try {
    await client.query(
      "INSERT INTO escalation_events(incident_key, level, unique_hash) VALUES ($1,$2,$3)",
      [incidentKey, level, h]
    );
    return true; // first time
  } catch (e) {
    if (e.code === "23505") return false; // duplicate
    throw e;
  }
}

async function notifySlack(webhook, payload, incidentKey, level, fetch) {
  const dedup = eventHash(incidentKey, level);
  await fetch(webhook, {
    method: "POST",
    headers: { "Content-Type": "application/json", "X-Dedup-Key": dedup },
    body: JSON.stringify({ ...payload, dedup_key: dedup })
  });
}
```

## Canary + feature flag in worker bootstrap

```js
function inCanary(incidentKey) {
  const pct = Number(process.env.ESC_CANARY_PCT || 0);
  if (pct >= 100) return true;
  const h = parseInt(crypto.createHash("md5").update(incidentKey).digest("hex").slice(0,8), 16);
  return (h % 100) < pct;
}

export async function escalationTick({ dryRun=false }) {
  if (process.env.ESCALATION_WORKER_ENABLED !== "true") return 0;
  const rows = await db.query(/* due SQL from above */);
  let escalations = 0;

  for (const inc of rows) {
    if (process.env.ESCALATION_V1 !== "true") break;
    if (!inCanary(inc.incident_key)) continue;

    const ok = await recordOnce(db, inc.incident_key, inc.escalation_level + 1);
    if (!ok) { metrics.inc("skipped_idempotent"); continue; }

    if (!dryRun) {
      await escalateIncident(inc);
      await notifySlack(resolveWebhook(inc), slackPayload(inc), inc.incident_key, inc.escalation_level + 1, fetch);
    }
    metrics.inc("escalations_count");
    escalations++;
  }
  return escalations;
}
```

## Metrics (pino + counters)

```js
import pino from "pino";
const log = pino();
export const metrics = {
  inc: (k, v=1)=>log.info({metric:k, v}),
  gauge: (k, v)=>log.info({metric:k, v})
};

// around tick
const t0 = Date.now();
const n = await escalationTick({ dryRun });
metrics.gauge("escalation_tick_ms", Date.now()-t0);
metrics.inc("escalations_count", n);
```

## Runbook one-pager (Notion)

* Pause: set `ESCALATION_WORKER_ENABLED=false`, deploy, verify logs.
* Drain: acknowledge or `UPDATE incidents SET escalation_level=GREATEST(escalation_level-1,0) WHERE incident_key=$1`.
* Recalc after SLA change: hit `POST /ops/escalation/recalc` (job recomputes `next_due_at` only).
* Audit last 24h: use the SQL you posted.

## Tests to copy

* Idempotent insert rejects second event.
* Canary 10% consistently selects same keys.
* Snooze blocks repeated escalation inside window.
* HMAC rejects tampered body.
* RBAC denies non-ops.

Suggestion: add a small “health” probe `GET /ops/escalation/health` returning `{enabled, v1, canaryPct, tickLagMs}` and wire an alert if `tickLagMs > 2*ESC_TICK_MS`.
