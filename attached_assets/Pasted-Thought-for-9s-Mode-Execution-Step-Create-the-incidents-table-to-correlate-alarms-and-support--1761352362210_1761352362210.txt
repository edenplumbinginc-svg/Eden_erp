Thought for 9s

[Mode: Execution]

Step: Create the incidents table to correlate alarms and support timed escalation. (Backend layer → DB schema)

Why it matters: We need a durable “incident object” to group related alarms (e.g., same route+kind) and track acknowledgment/escalation state.

Inputs needed: Your code editor, Drizzle/Postgres access, ability to run DB migrations.

Command (copy–paste):

Add schema file lib/db/schema/incidents.ts

import { pgTable, uuid, text, timestamp, integer, jsonb } from "drizzle-orm/pg-core";

export const incidents = pgTable("incidents", {
  id: uuid("id").defaultRandom().primaryKey(),

  // Correlation & identity
  incidentKey: text("incident_key").notNull(), // e.g., `${method} ${path}::${kind}`
  route: text("route").notNull(),              // e.g., "GET /notifications/recent"
  kind: text("kind").notNull(),                // "error_rate" | "latency" | "slo_violation"
  severity: text("severity").notNull(),        // "warning" | "critical"

  // Lifecycle
  status: text("status").notNull().default("open"), // "open" | "acknowledged" | "resolved" | "silenced"
  firstSeen: timestamp("first_seen", { withTimezone: true }).notNull().defaultNow(),
  lastSeen: timestamp("last_seen", { withTimezone: true }).notNull().defaultNow(),

  // Acknowledgment & escalation
  acknowledgedBy: text("acknowledged_by"),
  acknowledgedAt: timestamp("acknowledged_at", { withTimezone: true }),
  escalationLevel: integer("escalation_level").notNull().default(0),
  escalatedAt: timestamp("escalated_at", { withTimezone: true }),

  // Snapshot of owner at open-time + extra details
  owner: jsonb("owner").$type<{ owner?: string; slack_webhook?: string } | null>(),
  metadata: jsonb("metadata").notNull().default({}), // free-form: lastEvidence, sampleCounts, sentryUrl, etc.
});


Create SQL migration drizzle/20251024_add_incidents.sql

CREATE TABLE IF NOT EXISTS incidents (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  incident_key text NOT NULL,
  route text NOT NULL,
  kind text NOT NULL,
  severity text NOT NULL,

  status text NOT NULL DEFAULT 'open',
  first_seen timestamptz NOT NULL DEFAULT now(),
  last_seen timestamptz NOT NULL DEFAULT now(),

  acknowledged_by text,
  acknowledged_at timestamptz,
  escalation_level int NOT NULL DEFAULT 0,
  escalated_at timestamptz,

  owner jsonb,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_incidents_key ON incidents (incident_key);
CREATE INDEX IF NOT EXISTS idx_incidents_status ON incidents (status);
CREATE INDEX IF NOT EXISTS idx_incidents_route_kind ON incidents (route, kind);

-- Basic status guard (optional; app enforces states too)
-- You can tighten this later with an enum type.


Run migration (use whichever matches your setup):

# Option A: drizzle-kit (common)
npx drizzle-kit migrate

# Option B: psql apply (if you run raw SQL)
psql "$DATABASE_URL" -f drizzle/20251024_add_incidents.sql


Success check:

psql "$DATABASE_URL" -c "\d incidents"
# or
psql "$DATABASE_URL" -c "SELECT to_regclass('public.incidents');"
# should return: public.incidents


Next: wait for user

(When you confirm “Page created”—kidding, when you confirm the table exists—we’ll add the correlation rule: on each alarm, upsert an incident by incident_key = ${route}::${kind}, update last_seen, and leave the escalation timer hooks for the next step.)