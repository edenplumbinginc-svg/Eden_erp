[Mode: Execution]

Step: Add a **request-correlation ID** and **structured JSON logs** (Pino) to the backend so every request, error, and Sentry event shares the same `req_id`.

Why it matters: This is Phase 10B’s backbone. A per-request ID lets you stitch together console logs, Sentry errors, and future traces into one story—fast root-cause, no guesswork.

Inputs needed:

* Backend repo (Node/Express)
* Entry file (e.g., `server.js` or `src/index.ts`)
* You already have Sentry wired (`require("./instrument")` at top or equivalent)

Command:

1. Install logging deps:

```bash
npm install pino pino-http uuid
```

2. Create `logger.js` at project root:

```js
// logger.js — backend layer: Observability/Logging
const pino = require("pino");

const level = process.env.LOG_LEVEL || "info";
// Pino in JSON, safe for shipping to any log system later.
const logger = pino({
  level,
  messageKey: "message",
  redact: {
    paths: ["req.headers.authorization", "req.headers.cookie", "user.token", "password"],
    censor: "[REDACTED]"
  },
  base: {
    service: "eden-erp-backend",
    env: process.env.SENTRY_ENV || process.env.NODE_ENV || "dev",
  },
});

module.exports = logger;
```

3. In your server entry (very top, after `require("./instrument")`), add the correlation + HTTP logger:

```js
// Active Layer: Backend — Observability/Logging
const { v4: uuidv4 } = require("uuid");
const pinoHttp = require("pino-http");
const logger = require("./logger");

// 1) Request ID generator (before routers)
function requestId(req, res, next) {
  // Preserve upstream ID if present, else create one
  const hdr = req.headers["x-request-id"];
  const id = (typeof hdr === "string" && hdr.trim()) ? hdr.trim() : uuidv4();
  req.id = id;
  res.locals.req_id = id;
  res.setHeader("X-Request-Id", id);
  next();
}

// 2) Pino HTTP middleware (structured logs)
const httpLogger = pinoHttp({
  logger,
  customProps: (req, res) => ({
    req_id: req.id,
    user_id: res.locals?.user?.id || null,
    role: res.locals?.user?.role || null,
  }),
  // Keep bodies off by default for speed/privacy
  serializers: {
    req (req) {
      return {
        id: req.id,
        method: req.method,
        url: req.url,
        remoteAddress: req.remoteAddress,
        remotePort: req.remotePort,
        headers: {
          "user-agent": req.headers["user-agent"],
          "x-forwarded-for": req.headers["x-forwarded-for"],
        },
      };
    },
    res (res) {
      return { statusCode: res.statusCode };
    }
  }
});

// 3) Wire them up early (before routes)
app.use(requestId);
app.use(httpLogger);

// 4) OPTIONAL: add a tiny timing hook
app.use((req, res, next) => {
  const start = process.hrtime.bigint();
  res.on("finish", () => {
    const end = process.hrtime.bigint();
    const ms = Number(end - start) / 1e6;
    req.log.info({ req_id: req.id, duration_ms: ms }, "req_complete");
  });
  next();
});
```

4. Make sure your auth middleware (where you set `res.locals.user`) runs **before** routes. If it’s already there, you’re good—Pino will pick up `user_id` and `role`.

Success check:

* Hit any API route; your Replit console should print one JSON line per request.
* Each line must include `"req_id":"<uuid>"`, `"statusCode":200` (or other), and ends with `"req_complete"`.
* If you trigger `/api/_sentry-test`, the Sentry event should also include the same `req_id` in **tags** (Sentry picks it up from scope via existing wiring; if not, we’ll add a 1-line scope tag next).

Next: wait for user.
