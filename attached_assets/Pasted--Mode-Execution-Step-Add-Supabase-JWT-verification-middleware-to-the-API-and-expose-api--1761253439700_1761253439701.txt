[Mode: Execution]

**Step:** Add Supabase JWT verification middleware to the API and expose `/api/me/permissions` (connects real auth → RBAC).

**Why it matters:** This is the spine that lets your existing roles/permissions actually gate requests using real Supabase logins.

**Inputs needed:**

* Replit repo access
* Secrets already set: `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`
* Your Drizzle RBAC tables are present (`roles`, `permissions{code}`, `role_permissions`, `user_roles`)

**Command:**

1. Install API deps (skip if already present):

```bash
cd apps/api
npm i jose cross-fetch @supabase/supabase-js
```

2. Create `apps/api/src/auth/jwt.ts`:

```ts
import { createRemoteJWKSet, jwtVerify } from "jose";

const jwksUrl = new URL(`${process.env.SUPABASE_URL}/auth/v1/.well-known/jwks.json`);
const jwks = createRemoteJWKSet(jwksUrl);

export async function verifyJwt(token: string) {
  const { payload } = await jwtVerify(token, jwks, {
    issuer: process.env.SUPABASE_URL,        // Supabase sets iss to your project URL
    audience: process.env.JWT_AUD || "authenticated",
  });
  return payload as { sub: string; email?: string };
}
```

3. Create `apps/api/src/middleware/auth.ts`:

```ts
import type { Request, Response, NextFunction } from "express";
import { verifyJwt } from "../auth/jwt";
import { db } from "../db"; // your initialized drizzle instance
import { userRoles, rolePermissions, permissions, roles } from "../db/schema/rbac";
import { eq, inArray } from "drizzle-orm";

export async function requireAuth(req: Request, res: Response, next: NextFunction) {
  try {
    const header = req.headers.authorization || "";
    const token = header.startsWith("Bearer ") ? header.slice(7) : null;
    if (!token) return res.status(401).json({ error: "Missing bearer token" });

    const payload = await verifyJwt(token);
    const userId = payload.sub;
    (req as any).auth = { userId, email: payload.email };

    // load roles for user
    const urs = await db.select().from(userRoles).where(eq(userRoles.userId, userId as any));
    const roleIds = urs.map(u => u.roleId);

    let permSlugs: string[] = [];
    let roleSlugs: string[] = [];

    if (roleIds.length) {
      const rps = await db.select().from(rolePermissions).where(inArray(rolePermissions.roleId, roleIds));
      const permIds = rps.map(x => x.permissionId);
      if (permIds.length) {
        const perms = await db.select().from(permissions).where(inArray(permissions.id, permIds));
        // your column for the readable permission key is `code`
        permSlugs = perms.map((p: any) => p.code);
      }
      const rs = await db.select().from(roles).where(inArray(roles.id, roleIds));
      roleSlugs = rs.map((r: any) => r.slug);
    }

    (req as any).rbac = { permSet: new Set(permSlugs), roleSlugs };
    next();
  } catch {
    return res.status(401).json({ error: "Invalid token" });
  }
}

export function requirePerm(perm: string) {
  return (req: any, res: any, next: any) => {
    const set: Set<string> | undefined = req?.rbac?.permSet;
    if (!set || !set.has(perm)) return res.status(403).json({ error: "Forbidden" });
    next();
  };
}
```

4. Create `apps/api/src/routes/me.ts`:

```ts
import { Router } from "express";
import { requireAuth } from "../middleware/auth";
const router = Router();

router.get("/me/permissions", requireAuth, async (req: any, res) => {
  const { roleSlugs, permSet } = req.rbac;
  res.json({ roles: roleSlugs, permissions: Array.from(permSet) });
});

export default router;
```

5. Wire it in your API bootstrap (usually `apps/api/src/app.ts` or `index.ts`):

```ts
import meRoutes from "./routes/me";
// ...
app.use("/api", meRoutes);
```

**Success check:**

1. Without a token:

```bash
curl -i http://localhost:3000/api/me/permissions
# Expect: HTTP/1.1 401
```

2. With an invalid token:

```bash
curl -i -H "Authorization: Bearer badtoken" http://localhost:3000/api/me/permissions
# Expect: 401
```

3. With a real Supabase user token (after you log in via frontend or Supabase Auth UI), you should see:

```json
{ "roles": ["viewer"], "permissions": ["projects:read","tasks:read", "..."] }
```

**Next:** wait for user.

When you confirm 401/401 on the first two checks (or paste the token result), I’ll give **Step 1.5**: minimal frontend changes (Login/Register screens + bootstrap hook) and the single-line swap that hides DevAuthSwitcher behind real auth.
