[Mode: Execution]

Step: Set up Notion read-only mirror of decision_policies (governance sync) — one-way export from ERP → Notion database.

Why it matters: Puts your automation policies under clear governance: searchable, auditable, and shareable without app access.

Inputs needed:

Notion: an empty database for “Decision Policies”

Notion Integration Token (internal integration)

Database ID (the long hex string in the Notion URL)

Command (exact actions & code to paste):

Create the Notion DB (once)

In Notion: New → Database → Table (Full page), title: Decision Policies

Add properties (case-sensitive names):

Name (Title)

Slug (Text)

Enabled (Checkbox)

DRY_RUN (Checkbox)

Last Execution (Date)

External ID (Text) ← used as stable key

Copy the database ID from the URL.

Set secrets (Replit → Secrets)

NOTION_TOKEN=secret_xxx_from_notion
NOTION_DECISIONS_DB_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


Restart the app after saving.

Backend: add a minimal sync endpoint (paste as a new file)
File: src/integrations/notion/decisionsSync.ts

import fetch from 'node-fetch';
import { db } from '../../db';
import { decision_policies, decision_executions } from '../../db/schema';

const NOTION_API = 'https://api.notion.com/v1';
const VERSION = '2022-06-28';

async function upsertPolicy(p: {
  id: string; name: string; slug: string; enabled: boolean; dry_run: boolean;
  last_execution_at: string | null;
}) {
  const pageSearch = await fetch(`${NOTION_API}/databases/${process.env.NOTION_DECISIONS_DB_ID}/query`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.NOTION_TOKEN}`,
      'Notion-Version': VERSION,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      filter: { property: 'External ID', rich_text: { equals: p.id } },
      page_size: 1,
    }),
  }).then(r => r.json());

  const props = {
    'Name': { title: [{ text: { content: p.name } }] },
    'Slug': { rich_text: [{ text: { content: p.slug } }] },
    'Enabled': { checkbox: !!p.enabled },
    'DRY_RUN': { checkbox: !!p.dry_run },
    'Last Execution': p.last_execution_at ? { date: { start: p.last_execution_at } } : { date: null },
    'External ID': { rich_text: [{ text: { content: p.id } }] },
  };

  if (pageSearch?.results?.[0]?.id) {
    const pageId = pageSearch.results[0].id;
    await fetch(`${NOTION_API}/pages/${pageId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${process.env.NOTION_TOKEN}`,
        'Notion-Version': VERSION,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ properties: props }),
    });
  } else {
    await fetch(`${NOTION_API}/pages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.NOTION_TOKEN}`,
        'Notion-Version': VERSION,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        parent: { database_id: process.env.NOTION_DECISIONS_DB_ID },
        properties: props,
      }),
    });
  }
}

export async function syncDecisionsToNotion() {
  const policies = await db.select({
    id: decision_policies.id,
    name: decision_policies.name,
    slug: decision_policies.slug,
    enabled: decision_policies.enabled,
    dry_run: decision_policies.dry_run,
  }).from(decision_policies);

  // last execution per policy
  const lastExecs = await db.select({
    policy_id: decision_executions.policy_id,
    executed_at: decision_executions.executed_at,
  })
  .from(decision_executions)
  .orderBy(decision_executions.policy_id, decision_executions.executed_at.desc());

  const lastMap = new Map<string, string>();
  for (const row of lastExecs) if (!lastMap.has(row.policy_id)) lastMap.set(row.policy_id, row.executed_at?.toISOString?.() ?? row.executed_at as any);

  for (const p of policies) {
    await upsertPolicy({
      ...p,
      last_execution_at: lastMap.get(p.id) ?? null,
    });
  }

  return { count: policies.length };
}


Route: secure admin endpoint
File: src/routes/adminDecisionsNotion.ts

import { Router } from 'express';
import { requirePermission } from '../auth/requirePermission';
import { syncDecisionsToNotion } from '../integrations/notion/decisionsSync';

export const adminDecisionsNotion = Router();

adminDecisionsNotion.post('/admin/decisions/notion-sync', requirePermission('admin:manage'), async (_req, res) => {
  try {
    const result = await syncDecisionsToNotion();
    res.json({ ok: true, ...result });
  } catch (e:any) {
    res.status(500).json({ ok: false, error: String(e?.message ?? e) });
  }
});


Wire the route
File: src/server.ts (or your main router index)

import { adminDecisionsNotion } from './routes/adminDecisionsNotion';
app.use('/api', adminDecisionsNotion);


Manual sync test (dry run not needed; endpoint is idempotent)

curl -X POST https://APP_URL/api/admin/decisions/notion-sync \
  -H "Authorization: Bearer ADMIN_JWT"


Success check:

cURL returns {"ok":true,"count":N}

Notion database shows one row per policy with correct Name, Slug, Enabled, DRY_RUN, Last Execution, External ID.

Re-running the sync updates rows, does not duplicate.

Next: wait for user.