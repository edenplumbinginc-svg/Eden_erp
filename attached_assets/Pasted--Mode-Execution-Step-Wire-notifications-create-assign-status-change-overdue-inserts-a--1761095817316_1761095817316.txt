[Mode: Execution]

Step: Wire **notifications**: create/assign/status-change/overdue inserts + a **daily summary** job (scaffold) using your existing `notifications` table and in-memory queue.

Why it matters: People get told when work moves. Daily rollups keep managers in the loop without hunting dashboards.

Inputs needed:

* Backend repo (you already have `notifications` table + `services/queue.js`)
* Files: `routes/tasks.js`, `services/queue.js`, `server.js`

Command:

1. Add tiny queue job for emails/summaries (scaffold; prints to logs for now)

```js
// services/queue.js  (extend your existing scaffold)
const jobs = new Map();

export function registerJob(name, handler) { jobs.set(name, handler); }
export async function enqueue(name, payload) {
  const fn = jobs.get(name);
  if (!fn) throw new Error(`Unknown job: ${name}`);
  // fire-and-forget for now; swap to BullMQ later
  setImmediate(() => fn(payload).catch(err => console.error(`[job:${name}]`, err)));
}

// --- register default jobs ---
// 1) notify-user: single event fanout (email/push later)
registerJob("notify-user", async ({ userId, event, meta }) => {
  console.log(`[notify-user] → user=${userId} event=${event}`, meta || {});
});

// 2) daily-summary: build and "send" a digest (log for now)
registerJob("daily-summary", async ({ dateIso }) => {
  console.log(`[daily-summary] generating for ${dateIso}`);
  // TODO: replace with real email; for now prove it runs
});
```

2. Helper to insert notifications + enqueue job

```js
// utils/notify.js (new)
import { pool } from "../services/database.js";
import { enqueue } from "../services/queue.js";

export async function notify(userId, eventCode, payload = {}, taskId = null, projectId = null, actor = {}) {
  const client = await pool.connect();
  try {
    await client.query(
      `INSERT INTO notifications (user_id, channel, event_code, payload, task_id, project_id, actor_id, actor_email)
       VALUES ($1, 'inapp', $2, $3, $4, $5, $6, $7)`,
      [userId, eventCode, payload, taskId, projectId, actor.id ?? null, actor.email ?? null]
    );
  } finally {
    client.release();
  }
  await enqueue("notify-user", { userId, event: eventCode, meta: { taskId, projectId, ...payload } });
}
```

3. Trigger notifications from task create/assign/status

```js
// routes/tasks.js  (inside your existing handlers)
import { notify } from "../utils/notify.js";

// a) on CREATE task (after insert succeeds):
await notify(assignee_id, "task.created", { title, priority, due_at }, newTask.id, newTask.project_id, req.user);

// b) on ASSIGNEE change during PATCH (compare previous vs new):
if (patch.assignee_id && patch.assignee_id !== current.assignee_id) {
  await notify(patch.assignee_id, "task.assigned", { title: current.title }, taskId, current.project_id, req.user);
}

// c) on STATUS change during PATCH:
if (patch.status && patch.status !== current.status) {
  await notify(current.assignee_id, "task.status_changed", { from: current.status, to: patch.status, title: current.title }, taskId, current.project_id, req.user);
}
```

4. Nightly overdue notifier (simple scheduler)

```js
// server.js  (near startup)
import { pool } from "./services/database.js";
import { enqueue } from "./services/queue.js";

// run at 18:00 local server time (dev-friendly setInterval; swap to cron in prod)
const ONE_DAY = 24 * 60 * 60 * 1000;
async function runDailyOverdue() {
  const { rows } = await pool.query(`
    SELECT t.id, t.title, t.assignee_id, t.project_id, t.due_at
    FROM tasks t
    WHERE t.due_at IS NOT NULL AND t.due_at < now() AND t.status NOT IN ('done','closed')
  `);
  for (const r of rows) {
    await enqueue("notify-user", { userId: r.assignee_id, event: "task.overdue", meta: { taskId: r.id, title: r.title, due_at: r.due_at, project_id: r.project_id } });
  }
  // enqueue a daily summary job too (manager digest; swap to real recipients later)
  await enqueue("daily-summary", { dateIso: new Date().toISOString().slice(0,10) });
}
// dev timer: first run in 10s, then every 24h
setTimeout(runDailyOverdue, 10_000);
setInterval(runDailyOverdue, ONE_DAY);
```

5. (Optional) One-off endpoint to test digests now

```js
// routes/reports.js or routes/ops.js (new GET /api/ops/run-daily)
import { Router } from "express";
import { enqueue } from "../services/queue.js";
const router = Router();

router.post("/run-daily", async (req, res) => {
  await enqueue("daily-summary", { dateIso: new Date().toISOString().slice(0,10) });
  res.json({ ok: true });
});

export default router;
// and in server.js: app.use("/api/ops", opsRouter);
```

Success check:

* Create a task (as OPS) → terminal shows `[notify-user] … task.created`.
* Reassign a task → `[notify-user] … task.assigned`.
* Change status → `[notify-user] … task.status_changed`.
* Hit manual run: `curl -X POST http://localhost:3000/api/ops/run-daily` → logs `[daily-summary] generating…`.
* After a minute, an overdue task (set `due_at` to last week) logs `[notify-user] … task.overdue`.

Next: wait for user

When you confirm green, I’ll do one final Phase-1 step: **friendly toasts + inline banners on the front end** for these notifications (read-only list + subtle toasts when actions succeed/fail).
