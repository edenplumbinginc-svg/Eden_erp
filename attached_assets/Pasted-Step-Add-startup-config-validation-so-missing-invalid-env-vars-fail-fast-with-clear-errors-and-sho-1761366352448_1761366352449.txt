Step: Add startup config validation so missing/invalid env vars fail fast with clear errors (and show up in a small config health endpoint).

Why it matters: You just hardened ops; now make misconfigurations impossible to miss. This prevents spooky 5xx at runtime and speeds debugging.

Inputs needed: Backend repo access.

Command (copy–paste):

Create lib/config.ts

// lib/config.ts
import { z } from "zod";

const bool = z.enum(["true","false"]).transform(v => v === "true");
const int = (def: number) => z.string().regex(/^\d+$/).transform(Number).default(String(def));

const Schema = z.object({
  // Core
  NODE_ENV: z.string().default("development"),
  DATABASE_URL: z.string().url(),

  // Ops / Escalation
  ESCALATION_WORKER_ENABLED: bool.default("false"),
  ESCALATION_V1: bool.default("false"),
  ESC_CANARY_PCT: int(100),
  ESC_DRY_RUN: bool.default("true"),
  ESC_TICK_MS: int(60000),
  MAX_ESC_LEVEL: int(7),
  ESC_SNOOZE_MIN: int(30),

  // Security
  OPS_ADMIN_ROLE: z.string().default("ops_admin"),
  OPS_HMAC_SECRET: z.string().min(16, "OPS_HMAC_SECRET must be set (>=16 chars)"),

  // Optional
  APP_BASE_URL: z.string().url().optional(),
  SLACK_WEBHOOK_URL: z.string().url().optional(),
  SLACK_SIGNING_SECRET: z.string().optional(),
});

export type AppConfig = z.infer<typeof Schema>;

export function loadConfig(): AppConfig {
  const parsed = Schema.safeParse(process.env);
  if (!parsed.success) {
    const issues = parsed.error.issues.map(i => `- ${i.path.join(".")}: ${i.message}`).join("\n");
    // Fail fast with a crisp message
    console.error("❌ Config validation failed:\n" + issues);
    process.exit(1);
  }
  return parsed.data;
}

let _cfg: AppConfig | null = null;
export function cfg(): AppConfig {
  _cfg ??= loadConfig();
  return _cfg;
}

// Redacted snapshot for health/debug
export function cfgSnapshot() {
  const c = cfg();
  return {
    NODE_ENV: c.NODE_ENV,
    ESCALATION_WORKER_ENABLED: c.ESCALATION_WORKER_ENABLED,
    ESC_DRY_RUN: c.ESC_DRY_RUN,
    ESC_CANARY_PCT: c.ESC_CANARY_PCT,
    ESC_TICK_MS: c.ESC_TICK_MS,
    MAX_ESC_LEVEL: c.MAX_ESC_LEVEL,
    ESC_SNOOZE_MIN: c.ESC_SNOOZE_MIN,
    OPS_ADMIN_ROLE: c.OPS_ADMIN_ROLE,
    APP_BASE_URL: c.APP_BASE_URL ?? null,
    SLACK_WEBHOOK_URL: c.SLACK_WEBHOOK_URL ? "set" : "unset",
    SLACK_SIGNING_SECRET: c.SLACK_SIGNING_SECRET ? "set" : "unset",
    // Never print secrets
    OPS_HMAC_SECRET: "redacted",
    DATABASE_URL: "redacted",
  };
}


Use it in server bootstrap (replace ad-hoc process.env access):

// server.ts (top)
import { cfg } from "./lib/config";
// …
const C = cfg(); // throws (exit 1) if invalid


Expose a tiny config health endpoint (RBAC-protected optional, or open if you prefer):

// routes/ops-config.ts
import type { Express } from "express";
import { cfgSnapshot } from "../lib/config";

export function mountConfigHealth(app: Express) {
  app.get("/ops/config/health", (_req, res) => {
    res.json({ ok: true, config: cfgSnapshot() });
  });
}


Mount it:

// server.ts
import { mountConfigHealth } from "./routes/ops-config";
mountConfigHealth(app);


Success check:

# 1) Intentionally unset a required var and restart → process should exit with a clear list of missing/invalid keys
# 2) With secrets set, restart then:
curl -s https://<STAGING_HOST>/ops/config/health | jq
# Expect: ok: true and a redacted snapshot; booleans/ints reflect your secrets


Next: wait for user

(After this, we can flip DRY_RUN off safely, or move to “Update user profile editing to include new optional fields.” Your call.)