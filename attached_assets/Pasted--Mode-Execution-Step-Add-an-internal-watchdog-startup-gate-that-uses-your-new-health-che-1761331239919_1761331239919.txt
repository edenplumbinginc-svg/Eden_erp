[Mode: Execution]

Step: Add an internal **watchdog + startup gate** that uses your new health checks to auto-restart the process if the app is unhealthy (Layer: **Resilience → Auto-Restart Guard**).

Why it matters: If DB drops or the app boots in a bad state, the process should self-terminate so the platform restarts it quickly—no human babysitting.

Inputs needed:

* Your Express entry file (e.g., `server.js`)
* Access to the `getHealth` function (from the health module you just added)

Command:

1. **Expose your health getter** (only if not already):
   In `server.js`, where you wired health:

   ```js
   const { buildHealth } = require("./lib/health");
   const { db } = require("./db"); // adjust path if different
   const getHealth = buildHealth({ db });
   ```

2. **Add the startup gate** (fail fast if not ready right after boot):
   Put this **after** you call `app.listen(...)`:

   ```js
   // Active Layer: Resilience/Auto-Restart Guard — Startup gate
   (async () => {
     try {
       const h = await getHealth();
       const ok = h?.checks?.db?.ok === true;
       if (!ok) {
         console.error(JSON.stringify({ level: 50, msg: "startup_gate_failed", health: h }));
         // Non-zero exit triggers platform restart; use a special code for visibility
         process.exit(42);
       } else {
         console.log(JSON.stringify({ level: 30, msg: "startup_gate_ok", health: { status: h.status, db_ms: h.checks.db.ms } }));
       }
     } catch (e) {
       console.error(JSON.stringify({ level: 50, msg: "startup_gate_exception", error: String(e) }));
       process.exit(42);
     }
   })();
   ```

3. **Add a periodic watchdog** (exit if the app stays degraded for a while):
   Place near the startup gate code:

   ```js
   // Active Layer: Resilience/Auto-Restart Guard — Periodic watchdog
   const WATCH_MS = Number(process.env.WATCHDOG_INTERVAL_MS || 30000); // 30s
   const FAILS_TO_EXIT = Number(process.env.WATCHDOG_FAILS_TO_EXIT || 4); // ~2 min default
   let consecutiveFails = 0;

   setInterval(async () => {
     try {
       const h = await getHealth();
       const ok = h?.checks?.db?.ok === true;
       if (ok) {
         if (consecutiveFails > 0) {
           console.log(JSON.stringify({ level: 30, msg: "watchdog_recovered", consecutiveFails }));
         }
         consecutiveFails = 0;
         return;
       }
       consecutiveFails += 1;
       console.warn(JSON.stringify({ level: 40, msg: "watchdog_degraded", consecutiveFails, health: { status: h.status, db_ok: h.checks.db.ok, db_ms: h.checks.db.ms } }));
       if (consecutiveFails >= FAILS_TO_EXIT) {
         console.error(JSON.stringify({ level: 50, msg: "watchdog_exit", reason: "consecutive_degraded", count: consecutiveFails }));
         process.exit(43); // triggers platform restart
       }
     } catch (e) {
       consecutiveFails += 1;
       console.error(JSON.stringify({ level: 50, msg: "watchdog_exception", error: String(e), consecutiveFails }));
       if (consecutiveFails >= FAILS_TO_EXIT) process.exit(44);
     }
   }, WATCH_MS);
   ```

4. **Optional test switch** to simulate failure without touching DB:
   In `lib/health.js` (inside `getHealth()`), add at the top:

   ```js
   if (process.env.FORCE_HEALTH_FAIL === "true") {
     return {
       status: "degraded",
       checks: { db: { ok: false, ms: null } },
       env: process.env.SENTRY_ENV || "dev",
       version: process.env.RELEASE_SHA || "dev",
       build_time: process.env.BUILD_TIME || null,
       uptime_s: Math.floor(process.uptime()),
       resources: {},
       latency_ms: 0
     };
   }
   ```

Success check:

* Normal boot: server starts, logs `startup_gate_ok`.
* Simulated failure: set `FORCE_HEALTH_FAIL=true` in Replit Secrets and restart.

  * Expect `startup_gate_failed` and the process to exit (Replit will restart it).
* Ongoing guard: unset `FORCE_HEALTH_FAIL`, restart; then temporarily break DB or set `FORCE_HEALTH_FAIL=true` during runtime:

  * After ~2 minutes (default), expect `watchdog_exit` and automatic restart.
* Sentry remains quiet during healthy checks (no error storms); if exits happen, you’ll see a short downtime and a clean reboot in logs.

Next: wait for user.
