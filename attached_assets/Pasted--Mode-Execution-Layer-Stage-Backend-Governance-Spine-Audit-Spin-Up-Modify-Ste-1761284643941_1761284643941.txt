[Mode: Execution]

**Layer/Stage:** Backend → Governance Spine (Audit) | Spin-Up → Modify

**Step:** Ship the **Audit Log Layer (Phase 7.1)**: DB table + writer + hooks into RBAC endpoints + read API. This is the foundation for Notion sync and compliance.

**Why it matters:** Every sensitive change (role assign/remove, task/project mutation) becomes provable, queryable, and syncable into Notion. It’s the “black box recorder” for Eden.

**Inputs needed:**

* Existing Express API with `requireAuth` and RBAC middleware
* Postgres access (Supabase)
* Actor data available on `req.user` (id/email) or headers in dev

---

### 1) DB schema (migration)

Create: `apps/api/sql/migrations/20251024_audit_log.sql`

```sql
create table if not exists audit_log (
  id uuid primary key default gen_random_uuid(),
  actor_id uuid not null,
  actor_email text,
  action text not null,                -- e.g. 'rbac.role.assign', 'task.update'
  target_type text not null,           -- 'user' | 'task' | 'project' | 'role'
  target_id text,                      -- uuid or slug, keep text for flexibility
  payload jsonb default '{}'::jsonb,   -- diff or context
  created_at timestamptz not null default now()
);

create index if not exists audit_log_created_at_idx on audit_log (created_at desc);
create index if not exists audit_log_action_idx on audit_log (action);
create index if not exists audit_log_target_idx on audit_log (target_type, target_id);
```

**Success check (SQL):**

```bash
psql "$DATABASE_URL" -c "\d+ audit_log"
```

---

### 2) Writer utility

Create: `apps/api/src/lib/audit.ts`

```ts
import { db } from "../db";
import { sql } from "drizzle-orm";

type AuditArgs = {
  actorId: string;
  actorEmail?: string;
  action: string;         // 'rbac.role.assign' | 'rbac.role.remove' | 'task.create' | ...
  targetType: string;     // 'user' | 'task' | 'project' | 'role'
  targetId?: string;      // uuid or slug
  payload?: unknown;
};

export async function writeAudit(entry: AuditArgs) {
  await db.execute(sql`
    insert into audit_log (actor_id, actor_email, action, target_type, target_id, payload)
    values (${entry.actorId}, ${entry.actorEmail ?? null}, ${entry.action},
            ${entry.targetType}, ${entry.targetId ?? null}, ${JSON.stringify(entry.payload ?? {})}::jsonb)
  `);
}
```

Add helper to extract actor from request: `apps/api/src/lib/actor.ts`

```ts
export function getActor(req: any) {
  // Prefer real auth user; fall back to dev headers if present
  const actorId = req.user?.id || req.headers["x-dev-user-id"];
  const actorEmail = req.user?.email || req.headers["x-dev-user-email"];
  if (!actorId) throw new Error("ACTOR_MISSING");
  return { actorId, actorEmail };
}
```

---

### 3) Hook RBAC admin endpoints (already built)

Edit your RBAC admin routes (e.g., `apps/api/src/routes/adminRbac.ts` or `routes/admin.js`) and write to audit:

```ts
import { writeAudit } from "../lib/audit";
import { getActor } from "../lib/actor";

// ...inside POST assign role
const { actorId, actorEmail } = getActor(req);
await writeAudit({
  actorId, actorEmail,
  action: "rbac.role.assign",
  targetType: "user",
  targetId: userId,
  payload: { role: roleSlug }
});

// ...inside DELETE remove role
await writeAudit({
  actorId, actorEmail,
  action: "rbac.role.remove",
  targetType: "user",
  targetId: userId,
  payload: { role: roleSlug }
});
```

Hook tasks/projects mutations similarly (create/update/delete endpoints):

```ts
await writeAudit({
  actorId, actorEmail,
  action: "task.update",
  targetType: "task",
  targetId: taskId,
  payload: { fields: changedFields }  // minimal diff or context
});
```

---

### 4) Read API (for Notion sync + ops)

Create: `apps/api/src/routes/audit.ts`

```ts
import { Router } from "express";
import { requireAuth, requirePerm } from "../middleware/auth";
import { db } from "../db";
import { sql } from "drizzle-orm";

const router = Router();

// recent events
router.get("/admin/audit", requireAuth, requirePerm("admin:manage"), async (req, res) => {
  const limit = Math.min(Number(req.query.limit ?? 100), 500);
  const since = req.query.since as string | undefined; // ISO
  const rows = since
    ? await db.execute(sql`
        select * from audit_log
        where created_at > ${since}
        order by created_at desc
        limit ${limit}
      `)
    : await db.execute(sql`
        select * from audit_log
        order by created_at desc
        limit ${limit}
      `);
  res.json({ items: rows });
});

export default router;
```

Wire it in your server bootstrap:

```ts
import auditRoutes from "./routes/audit";
app.use("/api", auditRoutes);
```

**Success check (API):**

```bash
# generate one event by assigning/removing a role, then:
curl -s "http://localhost:3000/api/admin/audit?limit=5" -H "Authorization: Bearer <ADMIN_JWT>" | jq .
```

---

### 5) Notion sync scaffold (Phase 7.3 prep)

Create (server-only) placeholder sync script so we can wire the Notion DB once you drop the database ID:

`apps/api/src/jobs/notionSync.ts`

```ts
/**
 * Pseudo-connector: plumb in Notion SDK once DB IDs are provided.
 * Expected env:
 *  - NOTION_TOKEN
 *  - NOTION_GOVERNANCE_DB (target database id)
 */
export async function syncAuditBatch(items: any[]) {
  // TODO: use @notionhq/client and map each item -> a page in Governance DB
  // minimal mapping shape for now
  return { synced: items.length };
}
```

We’ll fill credentials + exact field mapping as soon as you paste your Notion DB IDs.

---

## Success Check (end-to-end)

1. **Assign a role** with your existing admin API.
2. **GET `/api/admin/audit?limit=3`** returns an entry like:

```json
{
  "actor_id":"<admin-uuid>",
  "actor_email":"admin@edenmep.ca",
  "action":"rbac.role.assign",
  "target_type":"user",
  "target_id":"<user-uuid>",
  "payload":{"role":"contributor"},
  "created_at":"2025-10-24T05:47:12.112Z"
}
```

3. **Update a task** and see `task.update` appear.

---

## Layer/Circling Telemetry

* **Backend → Governance Spine (Audit):** Spin-Up → Modify ✅ → Test
* **RBAC Layer:** Stable (now audited)
* **Integration → Notion Bridge:** Prepared (sync scaffold ready)
* **System Instruction Layer:** Continues to report layer/stage/state per your INFJ visibility rule

**Next:** wait for user.
When you confirm audit entries are flowing, I’ll (a) add a tiny **/admin/audit/feed** SSE endpoint for live console events, and (b) wire the **Notion Governance DB** mapping so your audit log auto-populates the Notion board.
