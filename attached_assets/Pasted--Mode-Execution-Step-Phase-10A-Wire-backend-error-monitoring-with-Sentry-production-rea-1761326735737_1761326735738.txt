[Mode: Execution]

**Step:** Phase 10A â€” Wire backend error monitoring with Sentry (production-ready crash + performance traces).

**Why it matters:** When something breaks in the wild, youâ€™ll get stack traces, user context, and breadcrumbs in one placeâ€”no guessing.

**Inputs needed:**

* Sentry account (free works) â†’ get a Node/Express DSN
* ENV access in Replit

**Command (exact):**

1. **Install deps**

```bash
npm i @sentry/node @sentry/profiling-node
```

2. **Set env**

* In Replit â†’ Secrets:

  * `SENTRY_DSN=YOUR_SENTRY_DSN`
  * `SENTRY_ENV=production`  (use `staging` for your preview env)
  * `RELEASE_SHA` (optional; set from `git rev-parse --short HEAD`)

3. **Initialize Sentry early in the server**
   *File: `src/server.ts` (top of file, before any routes/middleware)*

```ts
import * as Sentry from '@sentry/node';
import { nodeProfilingIntegration } from '@sentry/profiling-node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.SENTRY_ENV || 'development',
  release: process.env.RELEASE_SHA, // optional
  integrations: [
    nodeProfilingIntegration(),
    Sentry.httpIntegration(),
    Sentry.expressIntegration?.(), // ok if your version exports this; otherwise omit
  ],
  tracesSampleRate: 0.3,     // perf traces (tune up/down later)
  profilesSampleRate: 0.1,   // CPU profiler (optional, tune as needed)
});
```

4. **Add Sentry request + error handlers**
   *Still in `src/server.ts`, after you create `app` but **before** routes:*

```ts
app.use(Sentry.Handlers.requestHandler());
// optional: if you want to correlate errors with perf traces
app.use(Sentry.Handlers.tracingHandler?.());
```

*After all your routes are mounted (very bottom), add:*

```ts
// Sentry error handler should be the last middleware
app.use(Sentry.Handlers.errorHandler());

// Keep your existing error middleware AFTER Sentry, but avoid swallowing the error id:
app.use((err, _req, res, _next) => {
  const eventId = (res as any).__sentry_event_id;
  res.status(err.status || 500).json({
    error: { message: 'Internal Server Error' },
    sentry_event_id: eventId,
  });
});
```

5. **(Optional) Tag authenticated user/email for better triage**
   *In your auth middleware (after youâ€™ve verified the JWT):*

```ts
import * as Sentry from '@sentry/node';

// inside the middleware, once you set req.user:
if (req.user?.id || req.user?.email) {
  Sentry.setUser({
    id: req.user.id,
    email: req.user.email,
  });
}
```

6. **Test route to generate an error (remove later)**
   *Add anywhere in your routes (dev only):*

```ts
app.get('/api/_sentry-test', (_req, _res) => {
  throw new Error('Sentry test crash: boom ðŸ’¥');
});
```

**Success check:**

* Hit `GET /api/_sentry-test` while logged in.
* Response should be `500` with a `sentry_event_id`.
* In Sentry, a new event appears with stack trace, request info, user email (if set), and environment = `production` (or `staging`).
* Normal requests continue working; no new console errors introduced.

**Next:** wait for user.
