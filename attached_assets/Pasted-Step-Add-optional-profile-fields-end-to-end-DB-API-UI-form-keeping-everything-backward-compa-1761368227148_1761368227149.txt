Step: Add optional profile fields end-to-end (DB → API → UI form), keeping everything backward-compatible.

Why it matters: You’ll unblock real app testing without touching external chat; users can edit richer profiles now.

Inputs needed: Repo access (backend + frontend), DB URL.

Command (copy–paste):

DB migration — add nullable columns (no downtime)

-- 001_add_user_optional_fields.sql
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS phone            text,
  ADD COLUMN IF NOT EXISTS title            text,
  ADD COLUMN IF NOT EXISTS avatar_url       text,
  ADD COLUMN IF NOT EXISTS timezone         text,
  ADD COLUMN IF NOT EXISTS locale           text,
  ADD COLUMN IF NOT EXISTS notification_prefs jsonb DEFAULT '{}'::jsonb;

-- helpful index for lookup by phone (optional)
CREATE INDEX IF NOT EXISTS idx_users_phone ON users (phone);


API: read/update profile (validate & only update provided fields)

// routes/me.js (add/adjust)
const z = require("zod");
const Patch = z.object({
  phone: z.string().trim().min(7).max(32).optional(),
  title: z.string().trim().max(80).optional(),
  avatar_url: z.string().url().max(512).optional(),
  timezone: z.string().trim().max(64).optional(),
  locale: z.string().trim().max(16).optional(),
  notification_prefs: z.record(z.string(), z.any()).optional(),
}).strict();

app.get("/me/profile", requireAuth, async (req, res) => {
  const { rows } = await db.execute(/*sql*/`
    SELECT id, email, name, phone, title, avatar_url, timezone, locale, notification_prefs
    FROM users WHERE id = $1
  `, [req.auth.userId]);
  return rows[0] ? res.json(rows[0]) : res.status(404).json({ error: "not_found" });
});

app.patch("/me/profile", requireAuth, async (req, res) => {
  const data = Patch.parse(req.body || {});
  if (Object.keys(data).length === 0) return res.status(400).json({ error: "no_changes" });

  // build dynamic SET list
  const fields = Object.keys(data);
  const params = fields.map((k, i) => `${k} = $${i+1}`).join(", ");
  const values = fields.map(k => data[k]);
  values.push(req.auth.userId);

  const { rows } = await db.execute(
    `UPDATE users SET ${params} WHERE id = $${fields.length+1}
     RETURNING id, email, name, phone, title, avatar_url, timezone, locale, notification_prefs`,
    values
  );
  return rows[0] ? res.json(rows[0]) : res.status(404).json({ error: "not_found" });
});


UI form — surface fields (keep existing styling)

// apps/coordination_ui/src/pages/ProfileEdit.tsx (snippet)
const [form, setForm] = useState({
  phone: "", title: "", avatar_url: "", timezone: "", locale: "",
  notification_prefs: {}
});

// onSubmit:
await fetch("/me/profile", {
  method: "PATCH",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(Object.fromEntries(
    Object.entries(form).filter(([,v]) => v !== "" && v != null)
  ))
});


Success check:

Run migration; app restarts clean (no schema errors).

GET /me/profile returns new keys (possibly null).

PATCH /me/profile updates only sent fields; re-GET shows persisted values.

Form saves and reloads without 4xx/5xx.

Next: wait for user