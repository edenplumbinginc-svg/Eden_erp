[Mode: Execution]

Layer/Stage: Backend → Tasks Domain (Checklist RBAC) | Spin-Up → Modify

Step: Add Task Checklists as first-class items with strict RBAC (read/create/toggle/delete) so each task can carry a structured, permission-gated checklist.

Why it matters: This delivers your “Coordination Module = Checklists” priority, enforces role control, and lays the runway for timing/points later (we’ll timestamp each tick).

Inputs needed:

Express API + existing tasks table (UUID ids)

RBAC middleware (requireAuth, requirePerm)

Permissions you’ll use: tasks.checklist.read, tasks.checklist.write, tasks.checklist.delete (we’ll reference them)

Command (copy–paste):

DB migration (checklist table + indexes)

-- apps/api/sql/migrations/20251024_task_checklist.sql
create table if not exists task_checklist_items (
  id uuid primary key default gen_random_uuid(),
  task_id uuid not null references tasks(id) on delete cascade,
  label text not null,
  is_done boolean not null default false,
  position integer not null default 0,
  created_by uuid,
  updated_by uuid,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  done_at timestamptz
);

create index if not exists tci_task_pos_idx on task_checklist_items(task_id, position);
create index if not exists tci_task_done_idx on task_checklist_items(task_id, is_done);

-- optional: quick view for analytics later
create view if not exists v_task_checklist_progress as
select
  t.id as task_id,
  count(*) filter (where true) as total_items,
  count(*) filter (where is_done) as done_items
from task_checklist_items tci
join tasks t on tci.task_id = t.id
group by t.id;


Router (CRUD with RBAC)

// apps/api/src/routes/taskChecklist.ts
import { Router } from "express";
import { requireAuth, requirePerm } from "../middleware/auth";
import { db } from "../db";
import { sql } from "drizzle-orm";
import { getActor } from "../lib/actor";
import { writeAudit } from "../lib/audit";

const r = Router();

// List items
r.get("/tasks/:taskId/checklist", requireAuth, requirePerm("tasks.checklist.read"), async (req, res) => {
  const { taskId } = req.params;
  const rows = await db.execute(sql`
    select id, task_id, label, is_done, position, done_at, updated_at, created_at
    from task_checklist_items
    where task_id = ${taskId}
    order by position asc, created_at asc
  `);
  res.json({ items: rows });
});

// Create item
r.post("/tasks/:taskId/checklist", requireAuth, requirePerm("tasks.checklist.write"), async (req, res) => {
  const { taskId } = req.params;
  const { label, position = 0 } = req.body ?? {};
  if (!label?.trim()) return res.status(400).json({ error: "LABEL_REQUIRED" });
  const { actorId } = getActor(req);

  const row = await db.execute(sql`
    insert into task_checklist_items (task_id, label, position, created_by, updated_by)
    values (${taskId}, ${label}, ${position}, ${actorId}, ${actorId})
    returning id, task_id, label, is_done, position, done_at, updated_at, created_at
  `);

  await writeAudit({ actorId, action: "task.checklist.create", targetType: "task", targetId: taskId, payload: { label } });
  res.status(201).json(row[0]);
});

// Toggle done
r.post("/tasks/:taskId/checklist/:itemId/toggle", requireAuth, requirePerm("tasks.checklist.write"), async (req, res) => {
  const { taskId, itemId } = req.params;
  const { actorId } = getActor(req);

  const [existing] = await db.execute(sql`
    select is_done from task_checklist_items where id = ${itemId} and task_id = ${taskId}
  `);
  if (!existing) return res.status(404).json({ error: "ITEM_NOT_FOUND" });

  const newVal = !existing.is_done;
  const row = await db.execute(sql`
    update task_checklist_items
    set is_done = ${newVal}, done_at = (case when ${newVal} then now() else null end),
        updated_by = ${actorId}, updated_at = now()
    where id = ${itemId} and task_id = ${taskId}
    returning id, task_id, label, is_done, position, done_at, updated_at, created_at
  `);

  await writeAudit({
    actorId,
    action: newVal ? "task.checklist.done" : "task.checklist.undone",
    targetType: "task",
    targetId: taskId,
    payload: { itemId }
  });

  res.json(row[0]);
});

// Reorder (optional, stable insert)
r.post("/tasks/:taskId/checklist/reorder", requireAuth, requirePerm("tasks.checklist.write"), async (req, res) => {
  const { taskId } = req.params;
  const { order } = req.body as { order: string[] };
  if (!Array.isArray(order)) return res.status(400).json({ error: "ORDER_REQUIRED" });

  await db.execute(sql`begin`);
  for (let i = 0; i < order.length; i++) {
    await db.execute(sql`update task_checklist_items set position = ${i} where id = ${order[i]} and task_id = ${taskId}`);
  }
  await db.execute(sql`commit`);
  res.status(204).end();
});

// Delete item
r.delete("/tasks/:taskId/checklist/:itemId", requireAuth, requirePerm("tasks.checklist.delete"), async (req, res) => {
  const { taskId, itemId } = req.params;
  const { actorId } = getActor(req);

  const result = await db.execute(sql`
    delete from task_checklist_items where id = ${itemId} and task_id = ${taskId}
    returning id
  `);
  if (!result?.length) return res.status(404).json({ error: "ITEM_NOT_FOUND" });

  await writeAudit({ actorId, action: "task.checklist.delete", targetType: "task", targetId: taskId, payload: { itemId } });
  res.status(204).end();
});

export default r;


Mount routes

// apps/api/src/app.ts (or server.js)
import taskChecklist from "./routes/taskChecklist";
app.use("/api", taskChecklist);


Seed permissions (if not present)

-- apps/api/sql/migrations/20251024_task_checklist_perms.sql
insert into permissions (code, description) values
  ('tasks.checklist.read','Read task checklists'),
  ('tasks.checklist.write','Create/update checklist items'),
  ('tasks.checklist.delete','Delete checklist items')
on conflict (code) do nothing;

-- map to roles as you prefer; example:
insert into role_permissions (role_id, permission_id)
select r.id, p.id
from roles r, permissions p
where r.slug in ('admin','ops','pm','contributor')
  and p.code in ('tasks.checklist.read','tasks.checklist.write')
on conflict do nothing;

insert into role_permissions (role_id, permission_id)
select r.id, p.id
from roles r, permissions p
where r.slug in ('admin','pm')
  and p.code = 'tasks.checklist.delete'
on conflict do nothing;


Success check:

GET /api/tasks/{taskId}/checklist → 200 list (requires tasks.checklist.read).

POST /api/tasks/{taskId}/checklist {label} → 201, item created (requires tasks.checklist.write).

POST /api/tasks/{taskId}/checklist/{itemId}/toggle → 200, flips is_done, stamps done_at.

DELETE /api/tasks/{taskId}/checklist/{itemId} → 204 (requires tasks.checklist.delete).

GET /api/admin/audit?limit=10 shows task.checklist.* events flowing.

Next: wait for user.
Once this is in and green, I’ll activate Execution Step 2 (Frontend Layer → Tasks UI): drop-in <Checklist taskId=...> component with delta-sync + permission gates and micro-telemetry (so we can power timing/points without extra calls).