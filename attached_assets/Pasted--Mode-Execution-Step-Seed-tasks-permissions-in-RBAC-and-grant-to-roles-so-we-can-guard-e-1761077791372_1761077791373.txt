[Mode: Execution]

Step: Seed `tasks:*` permissions in RBAC (and grant to roles) so we can guard existing routes without breaking anything.

Why it matters: Your snapshot shows routes exist but lack `tasks:*` guards. Adding these permissions first lets us wire protections incrementally with zero downtime.

Inputs needed:

* `DATABASE_URL` working
* psql access OR permission to run a small seed script

Command (pick SQL **or** Node—both do the same thing):

**Option A — SQL (direct, idempotent)**

```sql
-- 1) Create permissions if missing
INSERT INTO permissions (code, description) VALUES
  ('tasks:read','Read tasks'),
  ('tasks:write','Create/update/delete tasks'),
  ('tasks:manage','Manage task settings & admin actions')
ON CONFLICT (code) DO NOTHING;

-- 2) Map convenience role ids
WITH r AS (SELECT id, slug FROM roles)
-- admin → everything
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id
FROM r
JOIN permissions p ON p.code IN ('tasks:read','tasks:write','tasks:manage')
WHERE r.slug = 'admin'
ON CONFLICT DO NOTHING;

-- viewer → read only
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id
FROM r
JOIN permissions p ON p.code = 'tasks:read'
WHERE r.slug = 'viewer'
ON CONFLICT DO NOTHING;

-- ops & coord → read/write
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id
FROM r
JOIN permissions p ON p.code IN ('tasks:read','tasks:write')
WHERE r.slug IN ('ops','coord')
ON CONFLICT DO NOTHING;

-- estimator/procurement/hr/marketing → read (adjust later per policy)
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id
FROM r
JOIN permissions p ON p.code = 'tasks:read'
WHERE r.slug IN ('estimator','procurement','hr','marketing')
ON CONFLICT DO NOTHING;

-- 3) Quick check
SELECT
  (SELECT COUNT(*) FROM permissions WHERE code LIKE 'tasks:%')  AS task_perms,
  (SELECT COUNT(*) FROM role_permissions rp JOIN permissions p ON p.id=rp.permission_id WHERE p.code LIKE 'tasks:%') AS grants;
```

**Option B — Node (fits your existing seed pattern)**

```js
// scripts/seed-tasks-perms.mjs
import 'dotenv/config';
import pkg from 'pg';
const { Client } = pkg;
const client = new Client({ connectionString: process.env.DATABASE_URL });
await client.connect();

const perms = [
  ['tasks:read','Read tasks'],
  ['tasks:write','Create/update/delete tasks'],
  ['tasks:manage','Manage task settings & admin actions'],
];

// upsert permissions
for (const [code, description] of perms) {
  await client.query(
    `INSERT INTO permissions (code, description) VALUES ($1,$2)
     ON CONFLICT (code) DO NOTHING`,
    [code, description]
  );
}

// helper to grant
async function grant(slug, codes){
  const { rows: [role] } = await client.query(`SELECT id FROM roles WHERE slug=$1`, [slug]);
  if (!role) return;
  for (const code of codes) {
    const { rows: [perm] } = await client.query(`SELECT id FROM permissions WHERE code=$1`, [code]);
    if (!perm) continue;
    await client.query(
      `INSERT INTO role_permissions (role_id, permission_id) VALUES ($1,$2)
       ON CONFLICT DO NOTHING`,
      [role.id, perm.id]
    );
  }
}

// grants
await grant('admin', ['tasks:read','tasks:write','tasks:manage']);
await grant('viewer', ['tasks:read']);
await grant('ops', ['tasks:read','tasks:write']);
await grant('coord', ['tasks:read','tasks:write']);
for (const slug of ['estimator','procurement','hr','marketing']) {
  await grant(slug, ['tasks:read']);
}

console.log('tasks:* permissions seeded & granted');
await client.end();
```

Add script and run:

```bash
# package.json
# "seed:rbac": "node ./scripts/seed-rbac.mjs",
# add:
# "seed:tasks-perms": "node ./scripts/seed-tasks-perms.mjs"

npm run seed:tasks-perms
```

Success check:

* `SELECT code FROM permissions WHERE code LIKE 'tasks:%';` returns 3 rows.
* `SELECT r.slug, p.code FROM role_permissions rp JOIN roles r ON r.id=rp.role_id JOIN permissions p ON p.id=rp.permission_id WHERE p.code LIKE 'tasks:%' ORDER BY r.slug, p.code;` shows grants per role as above.

Next: wait for user

Once confirmed, I’ll patch `routes/tasks.js` and `routes/attachments.js` to use `requirePerm('tasks:read|write')`, add Zod `validate(...)` on write routes, and drop in `audit()` calls—preserving your existing logic exactly.
