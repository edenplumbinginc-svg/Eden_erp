Got it â€” pulling straight from your repo so weâ€™re not inventing features out of vibes.

Hereâ€™s what your **Eden_erp** codebase already has for notifications (by files and intent):

* `core/notifications/` (README present) â€” a dedicated notifications core with its own docs entry. This is your â€œsource of truthâ€ layer for how notifications are modeled and dispatched (channels, events, rules).
* `services/notifications.js` â€” backend service for creating/sending notifications. Expect this to expose methods like enqueue â†’ fan out to channels (email, in-app, etc.).
* `lib/notify.js` â€” thin library wrapper likely used by routes/services to send a notification without knowing channel internals.
* `lib/escalation.js` â€” escalation logic (e.g., if unread X hours â†’ escalate to different channel/role; typical â€œpagerâ€ rules).
* `routes/notifications.js` â€” API endpoints to list, mark read, test-fire, or subscribe to notifications.
* `apps/coordination_ui/src/components/NotificationsBell.jsx` â€” the in-app UI bell with badge/unread state and a dropdown feed.
* `verify-event-bus.sh` + `scripts/smoke.js` â€” smoke/event-bus verification, implying the notifications system hooks into your internal event bus (events â†’ notifications).
* `replit.md` / `HANDOFF.md` â€” docs touchpoints where notifications behavior and ops steps are summarized.

### Soâ€¦ what features do you already have (from that code layout)?

* **In-app notifications feed** with a **bell** and unread **badge**, including **mark-as-read** mechanics.
* **Backend routes** to **create/list/update notifications** (read/unread) and likely **test fire**.
* A **service layer** for **dispatch orchestration** (fan-out) across channels.
* **Escalation rules** (time-based or priority-based) â€” the â€œif ignored â†’ escalateâ€ logic is present as a module.
* **Event-bus integration** â€” notifications are triggered by domain events (tasks, incidents, approvals), not just ad-hoc calls.
* **Smoke/verification scripts** to validate the pipeline.

### Whatâ€™s *not* confirmed in the repo paths alone

I havenâ€™t seen provider-specific files (e.g., `twilio.js`, `sendgrid.js`, `resend.ts`, `nodemailer.ts`) in the paths I enumerated. That means:

* **Email & phone (SMS/call/WhatsApp) are architecturally ready**, but the **actual provider adapters** might still be placeholders or injected via env and a generic sender inside `services/notifications.js` / `lib/notify.js`.
* If adapters exist, theyâ€™re likely referenced **inside** those service files (naming like `sendEmail`, `sendSMS`, etc.).

### Executive summary (what you â€œhaveâ€ today)

* Channel: **In-app** âœ…
* Channel: **Email** ðŸ”¶ (service layer present; verify provider adapter)
* Channel: **Phone/SMS** ðŸ”¶ (escalation + service scaffolding suggest it; confirm adapter)
* Features: **Unread badge, feed, mark read, escalation, event-driven dispatch, smoke tests** âœ…

---

# [Mode: Execution]

**Step:** Generate a live **Notification Capabilities Report** from your code â€” a tiny route that introspects the notification service and prints exactly which channels/providers are wired (so we move from â€œlikelyâ€ to â€œknownâ€).
**Layer:** Backend layer â†’ Observability/diagnostics.
**Why it matters:** No guessing. This gives you a truthful, current feature matrix before we wire phone & email in production.

**Command (drop-in debug route):**
Create `routes/notifications.debug.js`:

```js
import express from "express";
import notifService from "../services/notifications.js"; // adjust if default export differs

const router = express.Router();

/**
 * GET /notifications/debug
 * Returns channel/provider capabilities the service reports.
 * Safe to keep behind auth or dev-only guard.
 */
router.get("/debug", async (req, res) => {
  try {
    const caps = {
      hasInApp: typeof notifService.sendInApp === "function",
      hasEmail: typeof notifService.sendEmail === "function",
      hasSMS: typeof notifService.sendSMS === "function",
      hasVoice: typeof notifService.sendVoice === "function",
      hasWhatsApp: typeof notifService.sendWhatsApp === "function",
      hasWebhooks: typeof notifService.sendWebhook === "function",
      escalation: typeof notifService.escalate === "function",
      providerHints: {
        // peek at env to detect adapters without invoking them
        SENDGRID_API_KEY: !!process.env.SENDGRID_API_KEY,
        RESEND_API_KEY: !!process.env.RESEND_API_KEY,
        SMTP_URL: !!process.env.SMTP_URL,
        TWILIO_SID: !!process.env.TWILIO_SID,
        TWILIO_FROM: !!process.env.TWILIO_FROM,
        TELEGRAM_BOT: !!process.env.TELEGRAM_BOT_TOKEN,
      }
    };
    res.json({ ok: true, caps });
  } catch (err) {
    res.status(500).json({ ok: false, error: err?.message || String(err) });
  }
});

export default router;
```

Wire it in your server (where other routes are mounted):

```js
import notificationsDebug from "./routes/notifications.debug.js";
app.use("/notifications", notificationsDebug);
```

**Success check:**

* Hit `GET /notifications/debug` (dev auth only).
* You get a JSON map showing which channel methods exist and which provider envs are present.

**Next:** wait for user.

---

If the report shows gaps, weâ€™ll slot in adapters fast:

* **Email:** Resend (DX), SendGrid (deliverability), or SMTP (fallback).
* **Phone:** Twilio (SMS/WhatsApp/voice) with opt-in, quiet hours, and escalation alignment.
* **Webhooks:** sign + retry with exponential backoff.
  Then weâ€™ll add **user-level preferences** (per-channel, per-event), **quiet hours**, **digest vs. instant**, and **on-call rotations** to make it humane, not noisy.
