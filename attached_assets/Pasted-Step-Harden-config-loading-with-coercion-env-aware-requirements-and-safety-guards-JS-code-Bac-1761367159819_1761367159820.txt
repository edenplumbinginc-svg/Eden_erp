Step: Harden config loading with coercion, env-aware requirements, and safety guards (JS code). (Backend → startup reliability)

Why it matters: Prevents bad boots (wrong types, missing prod secrets), catches unsafe prod configs, and gives a clear /ops/config/health snapshot.

Inputs needed: Backend repo access.

Command (copy–paste):

Replace lib/config.js with coercion + prod guards

// lib/config.js
const { z } = require("zod");

const coerceBool = z.preprocess(v => String(v).trim().toLowerCase(), z.enum(["true","false"])).transform(v => v === "true");
const coerceInt  = (def, min, max) => z.preprocess(v => (v == null ? String(def) : String(v)), z.string().regex(/^\d+$/)).transform(n => {
  const x = Number(n); if (min != null && x < min) throw new Error(`must be >= ${min}`);
  if (max != null && x > max) throw new Error(`must be <= ${max}`); return x;
});

const Base = z.object({
  NODE_ENV: z.string().default("development"),
  DATABASE_URL: z.string().url({ message: "DATABASE_URL must be a valid URL" }),
  ESCALATION_WORKER_ENABLED: coerceBool.default("false"),
  ESCALATION_V1: coerceBool.default("false"),
  ESC_CANARY_PCT: coerceInt(100, 0, 100),
  ESC_DRY_RUN: coerceBool.default("true"),
  ESC_TICK_MS: coerceInt(60000, 1000, 600000), // 1s..10m
  MAX_ESC_LEVEL: coerceInt(7, 1, 99),
  ESC_SNOOZE_MIN: coerceInt(30, 1, 1440),
  OPS_ADMIN_ROLE: z.string().trim().min(3).default("ops_admin"),
  OPS_HMAC_SECRET: z.string().min(16, "OPS_HMAC_SECRET must be >=16 chars"),
  APP_BASE_URL: z.string().url().optional(),
  SLACK_WEBHOOK_URL: z.string().url().optional(),
  SLACK_SIGNING_SECRET: z.string().optional(),
});

function validateEnv(env) {
  // Parse and coerce
  const parsed = Base.safeParse(env);
  if (!parsed.success) {
    const issues = parsed.error.issues.map(i => `- ${i.path.join(".")}: ${i.message}`).join("\n");
    console.error("❌ Config validation failed:\n" + issues);
    process.exit(1);
  }
  const c = parsed.data;

  // Environment-aware *additional* guards
  const isProd = c.NODE_ENV === "production";
  if (isProd) {
    if (!c.APP_BASE_URL) die("APP_BASE_URL is required in production");
    if (new URL(c.DATABASE_URL).hostname === "localhost") die("DATABASE_URL must not point to localhost in production");
    if (c.ESC_DRY_RUN) warn("ESC_DRY_RUN=true in production — escalations will not send");
  }

  // Shadowing/unknown env keys (helps catch typos)
  const known = new Set(Object.keys(Base.shape));
  const unknown = Object.keys(env).filter(k => /^[A-Z0-9_]+$/.test(k) && !known.has(k));
  if (unknown.length) warn(`Unknown env keys: ${unknown.join(", ")}`);

  return c;

  function warn(msg) { console.warn("⚠️  Config warning:", msg); }
  function die(msg)  { console.error("❌ Config error:", msg); process.exit(1); }
}

let _cfg = null;
function cfg() { _cfg ??= validateEnv(process.env); return _cfg; }

function cfgSnapshot() {
  const c = cfg();
  return {
    NODE_ENV: c.NODE_ENV,
    APP_BASE_URL: c.APP_BASE_URL ?? null,
    DATABASE_URL: "redacted",
    OPS_HMAC_SECRET: "redacted",
    SLACK_SIGNING_SECRET: c.SLACK_SIGNING_SECRET ? "set" : "unset",
    SLACK_WEBHOOK_URL: c.SLACK_WEBHOOK_URL ? "set" : "unset",
    ESCALATION_WORKER_ENABLED: c.ESCALATION_WORKER_ENABLED,
    ESCALATION_V1: c.ESCALATION_V1,
    ESC_CANARY_PCT: c.ESC_CANARY_PCT,
    ESC_DRY_RUN: c.ESC_DRY_RUN,
    ESC_TICK_MS: c.ESC_TICK_MS,
    MAX_ESC_LEVEL: c.MAX_ESC_LEVEL,
    ESC_SNOOZE_MIN: c.ESC_SNOOZE_MIN,
    OPS_ADMIN_ROLE: c.OPS_ADMIN_ROLE,
    unknown_keys_note: "see server logs for any unknown env warnings",
  };
}

module.exports = { cfg, cfgSnapshot };


Use it at boot and add a config health route

// server.js (top)
const { cfg, cfgSnapshot } = require("./lib/config");
const C = cfg(); // fail fast if invalid

// …after other mounts
app.get("/ops/config/health", (_req, res) => res.json({ ok: true, config: cfgSnapshot() }));


Success check:

# 1) Break something intentionally (e.g., unset OPS_HMAC_SECRET) and restart
#    → process exits with a clear error message listing the missing/invalid keys.

# 2) With secrets set, verify snapshot (redacted & coerced types):
curl -s https://<STAGING_HOST>/ops/config/health | jq
# Expect booleans/ints as proper types, secrets redacted, and your current canary/dry-run shown.


Next: wait for user

(Once this is green, we can flip DRY_RUN off in staging for a short window, or move to “Update user profile editing to include new optional fields.”)