[Mode: Planning]

**Step:** Ship a fast “see-it-all” frontend polish pass + enforce **Route → Page coverage** so nothing ships half-built.

**Why it matters:** Backend is stable (guard passing, config hardened). Now is exactly the moment to expose everything visually, catch gaps, and lock CI so no missing pages slip through.

**Inputs needed:** Your repo (frontend + server), node/npm.

**Command (high-level plan):**

1. **Visibility First**

   * Add a **/showcase** landing with tiles linking to every major page (Projects, Tasks, Reports, Velocity, Incidents, Profile).
   * Add skeleton/empty/error/unauthorized states everywhere (no blank screens).
2. **Coverage Gate**

   * Introduce **docs/ui-contract.yaml** mapping API resources → required pages/states.
   * Add **scripts/check-ui-coverage.js** to fail CI if any required page or state is missing.
3. **Theme & Motion**

   * Centralize theme tokens (spacing, radius, shadow, color) + light/dark.
   * Wrap page transitions with a single **Framer Motion** fade/slide (subtle, <200ms).
4. **Smoke Navigation**

   * Add a tiny script that clicks through all routes (Playwright or Cypress minimal) and asserts at least a header + skeleton exists.
5. **Workflow & Differentiation**

   * Document the end-to-end workflow your app solves (field ops → tasks → incidents → guard).
   * Add a 1-pager “**Why Eden vs others**” (noise-free alerts, guard-driven deploys, ownership-based routing, incident correlation).
6. **Email→Task (two-way) & “BIC”**

   * Stage next: create `/inbox` and webhook stubs; keep out of this polish sprint to stay crisp.

**Success check:** `/showcase` lists live links; `npm run check:ui` passes; basic nav smoke test passes headless; consistent theme; subtle transitions.

---

[Mode: Execution]

**Step:** Add the **UI Coverage Gate** (contract + checker) and produce a **UI Gaps Report**.

**Why it matters:** This guarantees “no dummy pages.” CI will block merges if any required page/state is missing.

**Inputs needed:** Repo root path.

**Command:**

1. **Create the contract seed**

```bash
mkdir -p docs
cat > docs/ui-contract.yaml << 'YAML'
resources:
  - name: incidents
    routes:
      - GET   /ops/incidents
      - POST  /ops/incidents/:id/acknowledge
    required_pages:
      - /incidents
      - /incidents/[id]
    required_states: [loading, empty, error, unauthorized, not_found]

  - name: velocity
    routes:
      - GET /velocity
    required_pages:
      - /velocity
    required_states: [loading, error]

  - name: profile
    routes:
      - GET  /api/me/profile
      - PATCH /api/me/profile
    required_pages:
      - /profile
    required_states: [loading, error, unauthorized]
YAML
```

2. **Add the checker (pure JS)**

```bash
mkdir -p scripts
cat > scripts/check-ui-coverage.js << 'JS'
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");

const root = process.cwd();
// adjust these two to your app paths:
const pagesDir = path.join(root, "apps/coordination_ui/src/pages");
const appDir   = path.join(root, "apps/coordination_ui/src/app");

function pagePaths(route) {
  const clean = route.replace(/^\//, "");
  if (!clean) return { pages: "index.jsx", app: "page.jsx" };
  // Pages Router candidate
  const parts = clean.split("/");
  const last = parts[parts.length - 1];
  const pagesCandidate = last.startsWith("[")
    ? path.join(...parts, "index.jsx")
    : (parts.length === 1 ? path.join(parts[0], "index.jsx") : clean + ".jsx");
  // App Router candidate
  const appCandidate = path.join(clean, "page.jsx");
  return { pages: pagesCandidate, app: appCandidate };
}

function exists(route) {
  const { pages, app } = pagePaths(route);
  const pagesPath = path.join(pagesDir, pages);
  const appPath   = path.join(appDir, app);
  const tryExt = p => [p, p.replace(/\.jsx$/, ".tsx"), p.replace(/\.jsx$/, ".js"), p.replace(/\.jsx$/, ".ts")];
  return [...tryExt(pagesPath), ...tryExt(appPath)].some(p => fs.existsSync(p));
}

function main() {
  const specPath = path.join(root, "docs/ui-contract.yaml");
  if (!fs.existsSync(specPath)) {
    console.error("❌ Missing docs/ui-contract.yaml");
    process.exit(1);
  }
  const doc = yaml.load(fs.readFileSync(specPath, "utf8"));
  const missing = [];

  for (const res of doc.resources || []) {
    for (const route of res.required_pages || []) {
      if (!exists(route)) missing.push({ resource: res.name, route });
    }
  }

  if (missing.length) {
    console.error("❌ UI coverage check failed. Missing pages:");
    for (const m of missing) console.error(`  - ${m.resource}: ${m.route}`);
    process.exit(1);
  }
  console.log("✅ UI coverage satisfied for all declared resources.");
}
main();
JS
```

3. **Wire it to npm + CI**

```bash
npm i js-yaml --save-dev
# Add to package.json scripts:
# "check:ui": "node scripts/check-ui-coverage.js"
```

GitHub Actions step (or your CI):

```yaml
- name: UI coverage
  run: npm run check:ui
```

4. **Generate a quick gaps report locally**

```bash
node scripts/check-ui-coverage.js || true
# If it prints "Missing pages", that is your Gaps Report.
```

**Success check:**

* Running `npm run check:ui` prints ✅; if not, it lists the exact pages you still need to build.

---

If you want the **/showcase** page next (a single place to visually click every feature), I’ll ship it in the next step with minimal Framer Motion transitions and your theme tokens—then we run a tiny headless nav smoke to prove “it’s complete here.” After that I’ll deliver the **Workflow & Differentiation** one-pager comparing Eden to Slack/Linear/Jira (noise handling, incident correlation, release guard, owner routing).
