[Mode: Execution]

**Layer/Stage:** Backend → “Auto-Decisions v0” (Safe Rules Engine) | Spin-Up → Modify

**Step:** Ship a **minimal, safe-by-default** rules engine that uses your existing telemetry/audit to take low-risk actions automatically (with DRY-RUN on). Actions: notify/escalate, create templated handoff task, add a label. No destructive changes.

**Why it matters:** You want automatic decision-making soon. This gives you production leverage now without risking chaos, and it’s INFJ-proof: coherent rules, auditability, reversibility.

**Inputs needed:**

* Existing Express API + cron runner (or node schedule)
* Postgres/Supabase
* Your current RBAC + audit + performance tables

---

### 1) DB: policies & executions (idempotent, audited)

`apps/api/sql/migrations/20251024_decision_engine.sql`

```sql
create table if not exists decision_policies (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,                 -- 'handoff.estimation_to_procurement'
  enabled boolean not null default false,
  dry_run boolean not null default true,     -- start safe
  description text,
  condition jsonb not null,                  -- rule config (see below)
  action jsonb not null,                     -- what to do if rule matches
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists decision_executions (
  id uuid primary key default gen_random_uuid(),
  policy_slug text not null,
  matched boolean not null,
  dry_run boolean not null,
  effect text not null,                      -- 'notify' | 'create_task' | 'label'
  target_type text,                          -- 'task' | 'project' | 'user'
  target_id text,
  payload jsonb default '{}'::jsonb,         -- inputs/outputs
  created_at timestamptz not null default now()
);

create index if not exists decision_executions_policy_time_idx
  on decision_executions (policy_slug, created_at desc);
```

**Success check:**

```bash
psql "$DATABASE_URL" -c "\d+ decision_policies"
psql "$DATABASE_URL" -c "\d+ decision_executions"
```

---

### 2) Seed three pragmatic policies (readable JSON)

`apps/api/sql/migrations/20251024_decision_seed.sql`

```sql
-- 1) Auto-handoff: Estimation → Procurement when Estimation checklist hits 100%
insert into decision_policies (slug, enabled, dry_run, description, condition, action)
values
(
  'handoff.estimation_to_procurement',
  true,             -- enabled
  true,             -- start in DRY RUN
  'When an Estimation task completes, create a Procurement RFQ task.',
  jsonb_build_object(
    'type','task_checklist_complete',
    'department','Estimating'
  ),
  jsonb_build_object(
    'effect','create_task',
    'template', jsonb_build_object(
      'title_prefix','[AUTO] Procurement RFQ for ',
      'department','Procurement',
      'label','auto:handoff',
      'inherit_project', true
    )
  )
)
on conflict (slug) do nothing;

-- 2) Escalate overdue: if task idle > 7 days, notify ops lead
insert into decision_policies (slug, enabled, dry_run, description, condition, action)
values
(
  'escalate.idle_task_7d',
  true,
  true,
  'If a task is idle > 7 days and not done, notify Operations.',
  jsonb_build_object(
    'type','task_idle',
    'days',7
  ),
  jsonb_build_object(
    'effect','notify',
    'channel','inapp',
    'role','ops'
  )
)
on conflict (slug) do nothing;

-- 3) Speed badge probe: if checklist item finished under 1h, add label
insert into decision_policies (slug, enabled, dry_run, description, condition, action)
values
(
  'badge.lightning_fast_1h',
  true,
  true,
  'Award "Lightning Fast" label when a checklist item completes in < 60 minutes.',
  jsonb_build_object(
    'type','perf_event',
    'action','checklist.done',
    'lt_minutes',60
  ),
  jsonb_build_object(
    'effect','label',
    'label','badge:LightningFast'
  )
)
on conflict (slug) do nothing;
```

**Success check:**

```bash
psql "$DATABASE_URL" -c "select slug, enabled, dry_run from decision_policies;"
```

---

### 3) Engine service (pure functions + guards)

`apps/api/src/services/decisions.ts`

```ts
import { db } from "../db";
import { sql } from "drizzle-orm";

type Policy = {
  slug: string;
  enabled: boolean;
  dry_run: boolean;
  condition: any;
  action: any;
};

async function loadPolicies(): Promise<Policy[]> {
  return await db.execute(sql`select slug, enabled, dry_run, condition, action from decision_policies where enabled = true`);
}

async function recordExec(p: Policy, matched: boolean, effect: string, target: {type?: string,id?: string}, payload: any) {
  await db.execute(sql`
    insert into decision_executions (policy_slug, matched, dry_run, effect, target_type, target_id, payload)
    values (${p.slug}, ${matched}, ${p.dry_run}, ${effect}, ${target.type ?? null}, ${target.id ?? null}, ${JSON.stringify(payload)}::jsonb)
  `);
}

async function createTaskFromTemplate(taskId: string | null, projectId: string | null, tpl: any) {
  // minimal creation using existing tasks table
  const title = `${tpl.title_prefix || ""}${tpl.inherit_project ? (await projectName(projectId)) : ""}`.trim();
  const dept = tpl.department || null;
  const label = tpl.label || null;

  const [row] = await db.execute(sql`
    insert into tasks (title, project_id, department, labels, status, created_at, updated_at)
    values (${title}, ${projectId}, ${dept}, ${label ? sql`array[${label}]` : sql`null`}, 'open', now(), now())
    returning id
  `);
  return row?.id;
}

async function projectName(projectId: string | null) {
  if (!projectId) return "";
  const [p] = await db.execute(sql`select name from projects where id = ${projectId}`);
  return p?.name || "";
}

async function addTaskLabel(taskId: string, label: string) {
  await db.execute(sql`
    update tasks set labels = coalesce(labels, array[]::text[]) || ${label}, updated_at = now()
    where id = ${taskId}
  `);
}

async function notifyRole(role: string, message: string) {
  // stub: use your existing notifications table or in-app bus
  await db.execute(sql`
    insert into notifications (role, message, created_at) values (${role}, ${message}, now())
  `).catch(()=>{});
}

export async function runDecisionCycle() {
  const policies = await loadPolicies();

  // 1) perf_event rules → join recent performance_events
  const perf = policies.filter(p => p.condition?.type === 'perf_event');
  if (perf.length) {
    const recent = await db.execute(sql`
      select pe.id, pe.actor_id, pe.actor_email, pe.task_id, pe.checklist_item_id, pe.duration_ms, pe.created_at,
             t.project_id
      from performance_events pe
      left join tasks t on t.id = pe.task_id
      where pe.created_at >= now() - interval '2 hours'
        and pe.action = 'checklist.done'
    `);
    for (const p of perf) {
      for (const ev of recent) {
        const minutes = Number(ev.duration_ms) / 60000.0;
        const lt = Number(p.condition.lt_minutes ?? 0);
        const matched = minutes > 0 && minutes < lt;
        if (!matched) continue;

        const effect = p.action?.effect;
        if (effect === 'label' && ev.task_id) {
          const payload = { label: p.action.label, taskId: ev.task_id, minutes };
          await recordExec(p, true, 'label', {type:'task', id: ev.task_id}, payload);
          if (!p.dry_run) await addTaskLabel(ev.task_id, p.action.label);
        }
      }
    }
  }

  // 2) task_idle rules
  const idle = policies.filter(p => p.condition?.type === 'task_idle');
  if (idle.length) {
    for (const p of idle) {
      const days = Number(p.condition.days ?? 7);
      const rows = await db.execute(sql`
        select id, title, updated_at from tasks
        where status <> 'done' and updated_at < now() - (${days}::text || ' days')::interval
        limit 50
      `);
      for (const t of rows) {
        await recordExec(p, true, 'notify', {type:'task', id: t.id}, {title: t.title, days});
        if (!p.dry_run) await notifyRole(p.action.role || 'ops', `Task idle ${days}d: ${t.title}`);
      }
    }
  }

  // 3) handoff.estimation_to_procurement
  const handoff = policies.find(p => p.slug === 'handoff.estimation_to_procurement');
  if (handoff) {
    // find estimation tasks with 100% checklist done in last hour
    const rows = await db.execute(sql`
      with progress as (
        select t.id as task_id, t.project_id,
               count(*) filter (where true) as total,
               count(*) filter (where is_done) as done
        from task_checklist_items tci
        join tasks t on tci.task_id = t.id
        where t.department = 'Estimating'
        group by t.id, t.project_id
      )
      select p.task_id, p.project_id
      from progress p
      where p.total > 0 and p.total = p.done
      limit 30
    `);
    for (const row of rows) {
      await recordExec(handoff, true, 'create_task', {type:'project', id: row.project_id}, {fromTask: row.task_id});
      if (!handoff.dry_run) {
        const createdId = await createTaskFromTemplate(row.task_id, row.project_id, handoff.action.template);
        await recordExec(handoff, true, 'create_task', {type:'task', id: createdId}, {createdFrom: row.task_id});
      }
    }
  }
}
```

---

### 4) Cron wire-up + admin endpoints

`apps/api/src/jobs/decisionsRunner.ts`

```ts
import { runDecisionCycle } from "../services/decisions";

export async function tickDecisions() {
  try {
    await runDecisionCycle();
  } catch (e) {
    console.error("[DECISIONS] cycle failed", e);
  }
}
```

`apps/api/src/app.ts` (or `server.js`)

```ts
import cron from "node-cron";
import decisionsAdmin from "./routes/decisionsAdmin";
import { tickDecisions } from "./jobs/decisionsRunner";

app.use("/api/admin/decisions", decisionsAdmin);

// run every 5 minutes
cron.schedule("*/5 * * * *", () => tickDecisions());
```

`apps/api/src/routes/decisionsAdmin.ts`

```ts
import { Router } from "express";
import { requireAuth, requirePerm } from "../middleware/auth";
import { db } from "../db";
import { sql } from "drizzle-orm";
import { tickDecisions } from "../jobs/decisionsRunner";

const r = Router();

r.get("/policies", requireAuth, requirePerm("admin:manage"), async (_req, res) => {
  const rows = await db.execute(sql`select * from decision_policies order by slug`);
  res.json({ items: rows });
});

r.post("/run-once", requireAuth, requirePerm("admin:manage"), async (_req, res) => {
  await tickDecisions();
  res.json({ ok: true });
});

r.post("/toggle", requireAuth, requirePerm("admin:manage"), async (req, res) => {
  const { slug, enabled, dry_run } = req.body || {};
  const [row] = await db.execute(sql`
    update decision_policies
       set enabled = coalesce(${enabled}, enabled),
           dry_run = coalesce(${dry_run}, dry_run),
           updated_at = now()
     where slug = ${slug}
     returning *
  `);
  res.json({ item: row });
});

r.get("/executions", requireAuth, requirePerm("admin:manage"), async (req, res) => {
  const limit = Math.min(Number(req.query.limit || 50), 200);
  const rows = await db.execute(sql`
    select * from decision_executions order by created_at desc limit ${limit}
  `);
  res.json({ items: rows });
});

export default r;
```

---

### 5) Guardrails (INFJ-proof)

* **DRY_RUN = true by default** (records intent; no side-effects).
* **Only low-risk effects enabled**: `notify`, `create_task` (templated), `label`.
* **Audit always**: every match writes to `decision_executions`.
* **Idempotence**: effects reference IDs; templates are simple and traceable.
* **Admin-only toggles** (protected by `admin:manage`).

---

## Success check

1. Run migrations, seed, restart.

```bash
psql "$DATABASE_URL" -f apps/api/sql/migrations/20251024_decision_engine.sql
psql "$DATABASE_URL" -f apps/api/sql/migrations/20251024_decision_seed.sql
```

2. **List policies:**

```bash
curl -s http://localhost:3000/api/admin/decisions/policies \
  -H "Authorization: Bearer <ADMIN_JWT>" | jq .
```

3. **Manual run (DRY-RUN on):**

```bash
curl -s -X POST http://localhost:3000/api/admin/decisions/run-once \
  -H "Authorization: Bearer <ADMIN_JWT>" | jq .
curl -s http://localhost:3000/api/admin/decisions/executions \
  -H "Authorization: Bearer <ADMIN_JWT>" | jq '.items[0]'
```

Expect executions with `dry_run: true` and `effect` = “notify”/“create_task”/“label”.

4. **Flip one policy (surgical):**

```bash
curl -s -X POST http://localhost:3000/api/admin/decisions/toggle \
  -H "Authorization: Bearer <ADMIN_JWT>" \
  -H "Content-Type: application/json" \
  -d '{"slug":"badge.lightning_fast_1h","dry_run":false}' | jq '.item.slug,.item.dry_run'
```

Re-run and confirm a real label applied to a task that had <60min completion.

---

## Layer/Circling Telemetry

* **Auto-Decisions v0:** Spin-Up → Modify ✅ → Test ⏳
* **Policies:** 3 seeded (handoff, idle-escalate, speed-badge), DRY-RUN ON
* **Audit:** decision_executions flowing ✅
* **RBAC:** admin-only toggles ✅

**Next:** wait for user.
When you confirm executions appear in `/api/admin/decisions/executions`, I’ll:

* add **Notion mirror** (policies table → Notion Governance DB) so changes are visible/approved there,
* and wire **UI switches** (Admin → Decisions) with “Dry-run/Live” toggles and per-policy hit counters.
