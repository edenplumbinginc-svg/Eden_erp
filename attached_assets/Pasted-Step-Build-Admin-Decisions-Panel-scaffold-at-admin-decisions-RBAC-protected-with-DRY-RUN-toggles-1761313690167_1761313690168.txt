Step: Build Admin Decisions Panel scaffold at /admin/decisions (RBAC-protected) with DRY_RUN toggles, enable/disable, manual “Run Now”, and execution history.

Why it matters: This gives you safe visual control over automation—turn on/off policies, flip DRY_RUN, and audit effects without touching SQL.

Inputs needed:

Existing React app (same project)

Axios client (already present)

Admin permission (admin:manage or equivalent)

Command (exact code to paste):

API client — add admin decisions methods
File: apps/coordination_ui/src/services/api.js

+ // --- Admin Decisions API ---
+ export const decisionsApi = {
+   listPolicies: () => api.get('/api/admin/decisions/policies').then(r => r.data),
+   toggleEnabled: (policyId, enabled) =>
+     api.patch(`/api/admin/decisions/policies/${policyId}`, { enabled }).then(r => r.data),
+   setDryRun: (policyId, dryRun) =>
+     api.patch(`/api/admin/decisions/policies/${policyId}`, { dry_run: dryRun }).then(r => r.data),
+   runNow: (policyId) =>
+     api.post(`/api/admin/decisions/policies/${policyId}/run`).then(r => r.data),
+   listExecutions: ({ policyId, limit = 50, offset = 0 } = {}) =>
+     api.get('/api/admin/decisions/executions', { params: { policy_id: policyId, limit, offset }})
+        .then(r => r.data),
+   summary: () => api.get('/api/admin/decisions/summary').then(r => r.data),
+ };


Route — wire the page under auth
File: apps/coordination_ui/src/App.jsx

+ import DecisionsPage from './pages/admin/DecisionsPage';
  import RequireAuth from './components/RequireAuth';
  ...
+ <Route path="/admin/decisions" element={
+   <RequireAuth requiredPermission="admin:manage">
+     <DecisionsPage />
+   </RequireAuth>
+ } />


Nav link — show only for admins
File: apps/coordination_ui/src/components/EdenHeader.jsx

+ {hasPermission('admin:manage') && (
+   <a href="/admin/decisions" className="px-3 py-2 rounded hover:bg-[#e3f2fd]">
+     Admin · Decisions
+   </a>
+ )}


Page scaffold
Create: apps/coordination_ui/src/pages/admin/DecisionsPage.jsx

import React from 'react';
import { PolicyTable } from '../../components/admin/PolicyTable';
import { ExecutionHistory } from '../../components/admin/ExecutionHistory';
import { SummaryCards } from '../../components/admin/SummaryCards';

export default function DecisionsPage() {
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-2xl font-semibold">Automation · Decisions</h1>
      <SummaryCards />
      <PolicyTable />
      <ExecutionHistory />
    </div>
  );
}


Summary cards
Create: apps/coordination_ui/src/components/admin/SummaryCards.jsx

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { decisionsApi } from '../../services/api';

const Card = ({ label, value, sub }) => (
  <div className="rounded-2xl shadow p-4 border">
    <div className="text-sm text-gray-500">{label}</div>
    <div className="text-2xl font-semibold">{value}</div>
    {sub && <div className="text-xs text-gray-500 mt-1">{sub}</div>}
  </div>
);

export function SummaryCards() {
  const { data, isLoading, error } = useQuery(['decisions-summary'], decisionsApi.summary, { refetchInterval: 10000 });
  if (isLoading) return <div>Loading summary…</div>;
  if (error) return <div className="text-red-600">Failed to load summary</div>;
  const { total, enabled, dry_run_on, last_execution_at } = data || {};
  return (
    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
      <Card label="Policies" value={total ?? 0} />
      <Card label="Enabled" value={enabled ?? 0} />
      <Card label="DRY_RUN ON" value={dry_run_on ?? 0} />
      <Card label="Last Execution" value={last_execution_at ? new Date(last_execution_at).toLocaleString() : '—'} />
    </div>
  );
}


Policy table with enable + DRY_RUN + Run Now
Create: apps/coordination_ui/src/components/admin/PolicyTable.jsx

import React from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { decisionsApi } from '../../services/api';

export function PolicyTable() {
  const qc = useQueryClient();
  const { data, isLoading, error } = useQuery(['policies'], decisionsApi.listPolicies, { refetchInterval: 10000 });

  const mEnable = useMutation({
    mutationFn: ({ id, enabled }) => decisionsApi.toggleEnabled(id, enabled),
    onSuccess: () => qc.invalidateQueries(['policies']),
  });
  const mDry = useMutation({
    mutationFn: ({ id, dry_run }) => decisionsApi.setDryRun(id, dry_run),
    onSuccess: () => qc.invalidateQueries(['policies']),
  });
  const mRun = useMutation({
    mutationFn: ({ id }) => decisionsApi.runNow(id),
  });

  if (isLoading) return <div>Loading policies…</div>;
  if (error) return <div className="text-red-600">Failed to load policies</div>;

  const policies = data?.policies ?? [];

  return (
    <div className="rounded-2xl border shadow">
      <div className="p-4 font-medium bg-[#e3f2fd] rounded-t-2xl">Policies</div>
      <div className="p-4 overflow-x-auto">
        <table className="min-w-full text-sm">
          <thead>
            <tr className="text-left border-b">
              <th className="py-2 pr-4">Name</th>
              <th className="py-2 pr-4">Description</th>
              <th className="py-2 pr-4">Enabled</th>
              <th className="py-2 pr-4">DRY_RUN</th>
              <th className="py-2 pr-4">Last Exec</th>
              <th className="py-2 pr-4">Actions</th>
            </tr>
          </thead>
          <tbody>
            {policies.map(p => (
              <tr key={p.id} className="border-b hover:bg-gray-50">
                <td className="py-2 pr-4 font-medium">{p.name}</td>
                <td className="py-2 pr-4 text-gray-600">{p.description}</td>
                <td className="py-2 pr-4">
                  <label className="inline-flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={!!p.enabled}
                      onChange={e => mEnable.mutate({ id: p.id, enabled: e.target.checked })}
                    />
                    <span>{p.enabled ? 'On' : 'Off'}</span>
                  </label>
                </td>
                <td className="py-2 pr-4">
                  <label className="inline-flex items-center gap-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={!!p.dry_run}
                      onChange={e => mDry.mutate({ id: p.id, dry_run: e.target.checked })}
                    />
                    <span>{p.dry_run ? 'Simulated' : 'Live'}</span>
                  </label>
                </td>
                <td className="py-2 pr-4">{p.last_execution_at ? new Date(p.last_execution_at).toLocaleString() : '—'}</td>
                <td className="py-2 pr-4">
                  <button
                    className="px-3 py-1 rounded bg-black text-white"
                    onClick={() => mRun.mutate({ id: p.id })}
                    disabled={mRun.isLoading}
                  >
                    Run Now
                  </button>
                </td>
              </tr>
            ))}
            {!policies.length && (
              <tr><td className="py-4 text-gray-500" colSpan={6}>No policies found.</td></tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


Execution history with filter
Create: apps/coordination_ui/src/components/admin/ExecutionHistory.jsx

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { decisionsApi } from '../../services/api';

export function ExecutionHistory() {
  const [policyId, setPolicyId] = React.useState('');
  const { data, isLoading, error, refetch } = useQuery(
    ['dec-exec', policyId],
    () => decisionsApi.listExecutions({ policyId, limit: 50 }),
    { refetchInterval: 10000 }
  );

  const execs = data?.executions ?? [];

  return (
    <div className="rounded-2xl border shadow">
      <div className="p-4 bg-[#e3f2fd] rounded-t-2xl flex items-center gap-3">
        <div className="font-medium">Execution History</div>
        <input
          placeholder="Filter by policy_id (optional)"
          className="px-3 py-2 border rounded"
          value={policyId}
          onChange={e => setPolicyId(e.target.value)}
          onBlur={() => refetch()}
        />
      </div>
      <div className="p-4 overflow-x-auto">
        {isLoading && <div>Loading executions…</div>}
        {error && <div className="text-red-600">Failed to load executions</div>}
        {!isLoading && !execs.length && <div className="text-gray-500">No executions yet.</div>}
        {!!execs.length && (
          <table className="min-w-full text-sm">
            <thead>
              <tr className="text-left border-b">
                <th className="py-2 pr-4">Time</th>
                <th className="py-2 pr-4">Policy</th>
                <th className="py-2 pr-4">Effect</th>
                <th className="py-2 pr-4">Target</th>
                <th className="py-2 pr-4">DRY_RUN</th>
                <th className="py-2 pr-4">Payload</th>
              </tr>
            </thead>
            <tbody>
              {execs.map(x => (
                <tr key={x.id} className="border-b hover:bg-gray-50">
                  <td className="py-2 pr-4">{new Date(x.executed_at).toLocaleString()}</td>
                  <td className="py-2 pr-4">{x.policy_name || x.policy_id}</td>
                  <td className="py-2 pr-4">{x.effect}</td>
                  <td className="py-2 pr-4">{x.target_ref || '—'}</td>
                  <td className="py-2 pr-4">{x.dry_run ? 'Simulated' : 'Live'}</td>
                  <td className="py-2 pr-4">
                    <details><summary className="cursor-pointer">view</summary>
                      <pre className="text-xs whitespace-pre-wrap">{JSON.stringify(x.payload, null, 2)}</pre>
                    </details>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
}


Success check:

/admin/decisions is reachable only for admins (non-admins see access denied or redirect).

Summary cards show totals and last execution timestamp.

Policies table lists policies with working Enabled, DRY_RUN toggles, and Run Now triggers (verify 200s in Network).

Execution History shows last 50 with live updates; filtering by policy_id refetches.

No console errors; React Query polling occurs every 10s.

Cost note:

Incremental cost: essentially $0—UI-only; uses existing backend endpoints and your current Replit + AI subscription. No extra infrastructure.

Next: wait for user.