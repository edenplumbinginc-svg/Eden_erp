[Mode: Execution]

Step: Wire **Sentry on the React frontend** (minimal, no source-map upload) so UI errors + slow renders are captured and can link to backend traces.

Why it matters: Youâ€™ve finished backend observability (10Aâ€“10E). Frontend integration completes the loop. When a user clicks a button and something breaks, youâ€™ll see the **UI error**, the **API call**, and the **backend stack trace** as one story.

Inputs needed:

* Your React app (Vite)
* The same DSN you already used (we can split projects later if you want)
* Ability to edit `main.jsx/tsx` and add two env vars

Command:

1. Install SDK:

```bash
npm install @sentry/react
```

2. Add env vars (Vite uses VITE_*):

* In Replit â†’ Secrets:

  * `VITE_SENTRY_DSN` = your DSN (same one is fine for now)
  * `VITE_SENTRY_ENV` = `production`  (or `staging`)

3. Initialize Sentry at app startup (top of `src/main.jsx` or `src/main.tsx`, before React renders):

```tsx
// src/main.tsx (or main.jsx)
import * as Sentry from "@sentry/react";

// Basic frontend telemetry: errors + performance + session replays (light)
Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  environment: import.meta.env.VITE_SENTRY_ENV || "development",
  integrations: [
    Sentry.browserTracingIntegration(),
    Sentry.replayIntegration({ maskAllText: false, blockAllMedia: false }),
  ],
  tracesSampleRate: 0.2,           // performance sampling (keep modest)
  replaysSessionSampleRate: 0.05,  // 5% of sessions recorded
  replaysOnErrorSampleRate: 1.0,   // record sessions when an error occurs
});
```

4. Wrap your app with an error boundary (so user sees a friendly fallback and Sentry gets the report):

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import * as Sentry from "@sentry/react";

const Fallback = () => (
  <div style={{ padding: 16 }}>
    Something went wrong. Weâ€™ve logged it and will fix it fast.
  </div>
);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <Sentry.ErrorBoundary fallback={<Fallback />}>
    <App />
  </Sentry.ErrorBoundary>
);
```

Success check:

* Hard-refresh the app (env changes load).
* Trigger a test UI error anywhere (temporarily add `throw new Error("Frontend test crash: boom ðŸ’¥")` inside a button click or a component `useEffect`).
* In Sentry, you should now see a **new issue** from the React app with environment `production` (or your chosen value). If you perform that action while the app also calls your API, Sentry will display a **trace** that includes the frontend span and the backend request, joined by sampling (youâ€™ll often see both when an error/slow call occurs).

Next: wait for user.
