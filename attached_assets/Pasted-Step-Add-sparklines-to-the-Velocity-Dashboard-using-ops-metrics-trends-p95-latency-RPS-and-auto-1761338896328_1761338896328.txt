Step: Add sparklines to the Velocity Dashboard using /ops/metrics/trends (p95 latency, RPS) and auto-refresh every 10s. (Layer: Velocity → UI)

Why it matters: Snapshots are static; sparklines reveal performance drift and regressions at a glance.

Inputs needed:

Frontend repo (apps/coordination_ui)

Working /ops/metrics and /ops/metrics/trends endpoints

Command:

Patch the Velocity page to fetch trends and render inline SVG sparklines.

// apps/coordination_ui/src/pages/Velocity.jsx
import { useEffect, useMemo, useState } from "react";

function fmt(n) {
  if (n === null || n === undefined) return "—";
  if (typeof n === "number" && !Number.isInteger(n)) return n.toFixed(3);
  return String(n);
}

function Sparkline({ points, accessor = (x)=>x, height = 28, width = 120, strokeWidth = 1.5, title }) {
  // points: array of numbers (length ~30)
  const padX = 2, padY = 2;
  const w = width - padX * 2, h = height - padY * 2;

  const vals = points.map(accessor).filter(v => v !== null && v !== undefined);
  const min = vals.length ? Math.min(...vals) : 0;
  const max = vals.length ? Math.max(...vals) : 1;
  const span = max - min || 1;

  const stepX = w / Math.max(1, points.length - 1);

  const d = points.map((p, i) => {
    const yVal = accessor(p);
    const yNorm = yVal == null ? null : (1 - (yVal - min) / span);
    const x = padX + i * stepX;
    const y = yNorm == null ? null : padY + yNorm * h;
    return [x, y];
  });

  const path = d.reduce((acc, [x, y], i) => {
    if (y == null) return acc + (i === 0 ? `M${x},${padY + h}` : ` L${x},${padY + h}`);
    return acc + (i === 0 ? `M${x},${y}` : ` L${x},${y}`);
  }, "");

  // last point badge
  const last = d[d.length - 1];
  return (
    <svg width={width} height={height} aria-label={title}>
      <path d={path} fill="none" stroke="currentColor" strokeWidth={strokeWidth} />
      {last && last[1] != null && (
        <circle cx={last[0]} cy={last[1]} r="2" />
      )}
    </svg>
  );
}

export default function Velocity() {
  const [snap, setSnap] = useState(null);      // from /ops/metrics
  const [trends, setTrends] = useState(null);  // from /ops/metrics/trends
  const [err, setErr] = useState(null);
  const [sortBy, setSortBy] = useState("rps");
  const [desc, setDesc] = useState(true);
  const [since, setSince] = useState(null);

  async function fetchMetrics() {
    try {
      const [a, b] = await Promise.all([
        fetch("/ops/metrics", { cache: "no-store" }),
        fetch("/ops/metrics/trends", { cache: "no-store" }),
      ]);
      if (!a.ok) throw new Error(`/ops/metrics HTTP ${a.status}`);
      if (!b.ok) throw new Error(`/ops/metrics/trends HTTP ${b.status}`);
      const j1 = await a.json();
      const j2 = await b.json();
      setSnap(j1);
      setTrends(j2);
      setErr(null);
      setSince(new Date().toLocaleTimeString());
    } catch (e) {
      setErr(e.message || String(e));
    }
  }

  useEffect(() => {
    fetchMetrics();
    const id1 = setInterval(fetchMetrics, 10_000); // match 10s bucket
    return () => clearInterval(id1);
  }, []);

  const rows = useMemo(() => {
    if (!snap?.routes) return [];
    const out = [];
    for (const [route, wins] of Object.entries(snap.routes)) {
      const w1 = wins["1m"] || {};
      const tSeries = trends?.routes?.[route]?.series || [];
      out.push({
        route,
        rps: w1.rps ?? 0,
        p50_ms: w1.p50_ms ?? null,
        p95_ms: w1.p95_ms ?? null,
        err_rate: w1.err_rate ?? 0,
        count: w1.count ?? 0,
        trend: tSeries,
      });
    }
    return out.sort((a, b) => {
      const va = a[sortBy] ?? -Infinity;
      const vb = b[sortBy] ?? -Infinity;
      return desc ? (vb - va) : (va - vb);
    });
  }, [snap, trends, sortBy, desc]);

  function header(label, key) {
    return (
      <th
        className="px-3 py-2 cursor-pointer select-none"
        onClick={() => { setDesc(key === sortBy ? !desc : true); setSortBy(key); }}
        title={`Sort by ${label}`}
      >
        {label} {sortBy === key ? (desc ? "▾" : "▴") : ""}
      </th>
    );
  }

  return (
    <div className="p-6 space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Velocity Dashboard</h1>
        <div className="text-sm opacity-70">
          Env: {snap?.env ?? "—"} • Generated: {snap?.generated_at ?? "—"} • Last fetch: {since ?? "—"}
        </div>
      </div>

      {err && (
        <div className="p-3 rounded-md bg-red-50 text-red-700 border border-red-200">
          Failed to load metrics: {err}
        </div>
      )}

      <div className="overflow-auto border rounded-xl">
        <table className="min-w-full text-sm">
          <thead className="bg-gray-50">
            <tr>
              {header("Route", "route")}
              {header("RPS (1m)", "rps")}
              {header("p50 ms (1m)", "p50_ms")}
              {header("p95 ms (1m)", "p95_ms")}
              {header("Error % (1m)", "err_rate")}
              {header("Samples (1m)", "count")}
              <th className="px-3 py-2">p95 (5m)</th>
              <th className="px-3 py-2">RPS (5m)</th>
            </tr>
          </thead>
          <tbody>
            {rows.length === 0 ? (
              <tr><td className="px-3 py-4 text-center" colSpan="8">No data yet — hit some routes</td></tr>
            ) : rows.map((r) => (
              <tr key={r.route} className="border-t">
                <td className="px-3 py-2 font-mono">{r.route}</td>
                <td className="px-3 py-2">{fmt(r.rps)}</td>
                <td className="px-3 py-2">{fmt(r.p50_ms)}</td>
                <td className="px-3 py-2">{fmt(r.p95_ms)}</td>
                <td className={`px-3 py-2 ${r.err_rate > 5 ? "text-red-600 font-medium" : ""}`}>{fmt(r.err_rate)}</td>
                <td className="px-3 py-2">{fmt(r.count)}</td>
                <td className="px-3 py-1">
                  <Sparkline
                    points={r.trend}
                    accessor={(b)=>b?.p95_ms}
                    title={`p95 (5m) ${r.route}`}
                  />
                </td>
                <td className="px-3 py-1">
                  <Sparkline
                    points={r.trend}
                    accessor={(b)=>b?.rps}
                    title={`RPS (5m) ${r.route}`}
                  />
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <p className="text-xs opacity-70">
        Data sources: <code>/ops/metrics</code> (1m snapshot) & <code>/ops/metrics/trends</code> (5m, 10s buckets).
      </p>
    </div>
  );
}


No routing change needed if /velocity already exists. If not, register it:

import Velocity from "./pages/Velocity.jsx";
<Route path="/velocity" element={<Velocity />} />


Success check:

Visit /velocity. Within ~10s, two sparkline columns appear:

p95 (5m) shows recent latency trend.

RPS (5m) shows traffic trend.

Hit a couple of API routes; sparklines move on the next refresh and the 1m snapshot updates.

Next: wait for user.