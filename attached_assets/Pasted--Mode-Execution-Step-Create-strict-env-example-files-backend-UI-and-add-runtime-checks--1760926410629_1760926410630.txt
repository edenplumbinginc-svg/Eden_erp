[Mode: Execution]

Step: Create strict `.env.example` files (backend + UI) and add runtime checks so missing envs fail fast.

Why it matters: Your sync is green today; env drift is the fastest way to break it tomorrow. This locks UI/API headers and DB config in one, testable place.

Inputs needed:

* Your repo root with `server.js` (backend) and `apps/coordination_ui` (UI).
* The exact dev header keys you’re already using.

Command:

1. **Backend env contract**

```bash
# repo root
cat > .env.example <<'EOF'
# --- Database (Neon) ---
DATABASE_URL=postgresql://USER:PASSWORD@HOST:PORT/DB?sslmode=require
PGHOST=
PGDATABASE=
PGUSER=
PGPASSWORD=
PGPORT=5432

# --- Dev identity headers (match backend expectation) ---
DEV_HEADER_USER=X-Dev-User
DEV_HEADER_ROLE=X-Dev-Role
DEV_HEADER_EMAIL=X-Dev-Email
EOF
```

Add a tiny guard at the top of `server.js` (right after imports):

```js
// env-guard (fail fast on missing critical vars)
const required = ['DATABASE_URL'];
const missing = required.filter(k => !process.env[k] || String(process.env[k]).trim() === '');
if (missing.length) {
  console.error(`Missing required env: ${missing.join(', ')}`);
  process.exit(1);
}
```

2. **UI env contract**

```bash
cat > apps/coordination_ui/.env.example <<'EOF'
VITE_API_URL=http://localhost:3000

# Dev identity values used by the API client:
VITE_DEV_USER=test@example.com
VITE_DEV_ROLE=Manager
VITE_DEV_EMAIL=test@example.com
EOF
```

Ensure your UI client reads these (adjust keys only if your backend uses different header *names*):

```ts
// apps/coordination_ui/src/lib/api.ts
export const API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3000';

function devHeaders(): Record<string, string> {
  return {
    'X-Dev-User':  import.meta.env.VITE_DEV_USER  || 'test@example.com',
    'X-Dev-Role':  import.meta.env.VITE_DEV_ROLE  || 'Manager',
    'X-Dev-Email': import.meta.env.VITE_DEV_EMAIL || 'test@example.com',
  };
}
```

3. **Quick verification**

```bash
# simulate clean env
mv .env .env.bak 2>/dev/null || true
node server.js || true   # should print "Missing required env: DATABASE_URL" and exit
mv .env.bak .env 2>/dev/null || true

# UI build should still boot with .env.local present
npm run -C apps/coordination_ui dev
```

Success check:

* Running `node server.js` without `.env` exits immediately with a clear “Missing required env: DATABASE_URL”.
* UI dev server runs using `apps/coordination_ui/.env.local`.
* `.env.example` files exist and reflect your working values (minus secrets).

Next: wait for user

—
Quick training: shipping teams break on *implicit* configuration. Making env explicit and executable (examples + guards) is the cheapest reliability upgrade. When you’re done, paste your current `src/lib/api.ts` and any custom header names so I can align them perfectly. Also log this in Notion → “ERP Master Plan → Coordination UI → Phase 2 – Env contracts & guards (done)”.
