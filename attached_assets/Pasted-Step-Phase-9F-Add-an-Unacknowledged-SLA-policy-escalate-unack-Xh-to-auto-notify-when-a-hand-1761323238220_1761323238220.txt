Step: Phase 9F — Add an “Unacknowledged > SLA” policy (escalate.unack_Xh) to auto-notify when a handoff isn’t acknowledged within a threshold (default 48h), and surface it in the existing Admin Decisions panel.

Why it matters: This turns your new Court Flow data into action: the system nudges humans when the ball is dropped, before work stalls.

Inputs needed:

DB + backend (Node/Express)

Existing Decisions engine & Admin panel

Command (paste/apply exactly):

1) Config table (optional but clean) — SLA thresholds

-- drizzle/migrations/0019_add_sla_thresholds.sql
CREATE TABLE IF NOT EXISTS sla_thresholds (
  key text PRIMARY KEY,
  value_seconds integer NOT NULL,
  updated_at timestamptz NOT NULL DEFAULT now()
);

INSERT INTO sla_thresholds (key, value_seconds)
VALUES ('unacknowledged_handoff_sla', 48*3600)
ON CONFLICT (key) DO UPDATE SET value_seconds = EXCLUDED.value_seconds, updated_at = now();


2) Register a decision policy row (so it appears in Admin UI)

-- drizzle/migrations/0020_seed_policy_unack_sla.sql
INSERT INTO decision_policies (slug, name, description, enabled, dry_run)
VALUES (
  'escalate.unack_48h',
  'Escalate unacknowledged handoffs beyond SLA',
  'If a ball-in-court handoff is not acknowledged within the SLA window, notify the project owner/department lead.',
  false,
  true
)
ON CONFLICT (slug) DO NOTHING;


3) Engine rule — find stale, unacknowledged handoffs and notify
File: src/decisions/policies/escalateUnackSLA.ts

import { db } from '../../db';
import { sql } from 'drizzle-orm';
import { decisionsNotify } from '../shared/notify'; // your existing notifier
import { recordDecisionExecution } from '../shared/recordExec'; // your UPSERT logger

export async function runEscalateUnackSLA(policy: { id: string; slug: string }, dryRun: boolean) {
  // read SLA (fallback 48h)
  const { rows: cfg } = await db.execute(sql`
    SELECT value_seconds FROM sla_thresholds WHERE key = 'unacknowledged_handoff_sla'
  `);
  const sla = Number(cfg?.[0]?.value_seconds ?? 48*3600);

  // candidates: unacknowledged events older than SLA
  const { rows: events } = await db.execute(sql`
    SELECT e.id as event_id, e.task_id, e.to_role, e.created_at, t.title, t.project_id
    FROM ball_in_court_events e
    JOIN tasks t ON t.id = e.task_id
    WHERE e.acknowledged = false
      AND e.created_at <= now() - make_interval(secs => ${sla})
    ORDER BY e.created_at ASC
    LIMIT 100
  `);

  for (const ev of events) {
    const payload = {
      kind: 'handoff_unack_sla',
      task_id: ev.task_id,
      event_id: ev.event_id,
      to_role: ev.to_role,
      title: ev.title,
      message: `Unacknowledged handoff (${ev.to_role}) exceeded SLA (${Math.round(sla/3600)}h).`,
    };

    // effect = notify (email/slack/inbox). target_ref can be the task id.
    await recordDecisionExecution({
      policyId: policy.id,
      effect: 'notify',
      targetRef: ev.task_id,
      payload,
      dryRun,
      perform: async () => {
        // send the alert only when NOT dryRun
        await decisionsNotify({ toRole: ev.to_role, taskId: ev.task_id, payload });
      }
    });
  }
}


4) Wire policy into the engine cycle
File: src/decisions/runner.ts

import { runEscalateUnackSLA } from './policies/escalateUnackSLA';

async function runPolicy(policy) {
  switch (policy.slug) {
    case 'escalate.unack_48h':
      return runEscalateUnackSLA(policy, policy.dry_run);
    // ...existing cases
  }
}


5) Admin API already handles toggles
No UI changes required: the policy appears in /admin/decisions with Enabled and DRY_RUN controls.
(Optional) Add a small helper to update SLA from API later; for now, default is 48h via the config table.

Success check:

Policy appears in Admin → Decisions with slug escalate.unack_48h.

With at least one unacknowledged event older than 48h (or temporarily set SLA to 60 seconds for testing), click Run Now → an execution row logs (effect=notify).

In DRY_RUN: history shows Mode=Simulated, Result=Failed (by design; not executed).

Switch to LIVE and run again: history shows Success=true, and your notifier receives one alert per stale event (no duplicates on repeat runs thanks to action hash).

Next: wait for user.