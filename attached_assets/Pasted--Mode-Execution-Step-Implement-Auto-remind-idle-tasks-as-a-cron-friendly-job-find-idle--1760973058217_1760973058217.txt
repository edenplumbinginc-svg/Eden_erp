[Mode: Execution]

**Step:** Implement “Auto-remind idle tasks” as a cron-friendly job (find idle tasks with no activity in X days → insert a notification)

**Why it matters:** This closes the automation loop—nothing goes stale without a ping, which unlocks reliable Phase 2 behavior.

**Inputs needed:**

* Your repo (API runs with `DATABASE_URL`)
* `.env` edit permission
* Your current task + activity log schema (paste after you run this so I can align triggers)

**Command (copy–paste steps exactly):**

1. **Set threshold in `.env`:**

```
echo 'REMIND_IDLE_AFTER_DAYS=2' >> .env
```

2. **Migration: ensure `last_activity_at` and upsert trigger.** Create `migrations/20251020_idle_reminders.sql`:

```sql
-- Ensure column on tasks
alter table if exists tasks
  add column if not exists last_activity_at timestamp with time zone;

-- Backfill from latest activity if you have activity_log; else fallback to updated_at/created_at
do $$
begin
  if exists (select 1 from information_schema.tables where table_name='activity_log') then
    update tasks t
    set last_activity_at = coalesce((
      select max(a.created_at) from activity_log a where a.task_id = t.id
    ), t.updated_at, t.created_at);
  else
    update tasks t set last_activity_at = coalesce(t.updated_at, t.created_at);
  end if;
end$$;

-- Trigger function: whenever activity_log gets a row, bump task.last_activity_at
create or replace function trg_task_touch_on_activity()
returns trigger language plpgsql as $$
begin
  update tasks set last_activity_at = new.created_at where id = new.task_id;
  return new;
end$$;

-- Attach trigger if activity_log exists
do $$
begin
  if exists (select 1 from information_schema.tables where table_name='activity_log') then
    if not exists (
      select 1 from pg_trigger where tgname = 'activity_touch'
    ) then
      create trigger activity_touch
      after insert on activity_log
      for each row execute function trg_task_touch_on_activity();
    end if;
  end if;
end$$;

-- Helper index for the job
create index if not exists idx_tasks_last_activity on tasks (last_activity_at);

-- Ensure notifications table exists with task linkage (adjust names if different)
create table if not exists notifications (
  id uuid primary key default gen_random_uuid(),
  task_id uuid references tasks(id) on delete cascade,
  type text not null,
  payload jsonb not null default '{}',
  created_at timestamp with time zone not null default now()
);

create index if not exists idx_notifications_task on notifications(task_id);
```

Apply it:

```
psql "$DATABASE_URL" -X -f migrations/20251020_idle_reminders.sql
```

3. **Job script.** Add `jobs/idleReminder.js`:

```js
// jobs/idleReminder.js
const { Client } = require("pg");
require("dotenv").config({ override: true });

const DAYS = parseInt(process.env.REMIND_IDLE_AFTER_DAYS || "2", 10);

(async () => {
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();

  // Tune statuses to your schema; exclude terminal states
  const q = `
    with candidates as (
      select
        t.id as task_id,
        t.title,
        t.assignee_id,
        t.project_id,
        now() - coalesce(t.last_activity_at, t.updated_at, t.created_at) as idle_for
      from tasks t
      where coalesce(t.status,'') not in ('done','closed','cancelled')
        and coalesce(t.due_date, now() + interval '100 years') >= now() - interval '365 days'
        and coalesce(t.last_activity_at, t.updated_at, t.created_at) <= now() - ($1::int || ' days')::interval
    ),
    dedup as (
      -- avoid spamming: only one reminder per task per day
      select c.*
      from candidates c
      left join notifications n
        on n.task_id = c.task_id
       and n.type = 'idle_reminder'
       and n.created_at >= (now()::date)  -- today
      where n.id is null
    )
    insert into notifications (task_id, type, payload)
    select
      d.task_id,
      'idle_reminder',
      jsonb_build_object(
        'title', 'Task idle reminder',
        'message', 'No updates in ' || $1 || ' days',
        'idle_days', $1,
        'suggested_action', 'Post an update or reassign ball-in-court'
      )
    from dedup d
    returning id, task_id;
  `;

  const { rows } = await client.query(q, [DAYS]);
  console.log(`Inserted ${rows.length} idle reminders.`);
  if (rows.length) {
    console.table(rows);
  }

  await client.end();
})().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

4. **Package script.** Update `package.json`:

```json
{
  "scripts": {
    "job:idle": "node jobs/idleReminder.js"
  }
}
```

5. **Seed a test idle task (optional quick check):**

```bash
psql "$DATABASE_URL" -X -c "insert into tasks (id,title,status,created_at,updated_at,last_activity_at) values (gen_random_uuid(),'Idle Demo','open', now()-interval '5 days', now()-interval '5 days', now()-interval '5 days');"
```

6. **Run the job:**

```
npm run job:idle
```

**Success check:**

* Terminal prints `Inserted N idle reminders.` with `N >= 1` when a qualifying task exists.
* DB shows notifications for those tasks:

```
psql "$DATABASE_URL" -X -P pager=off -c "select task_id,type,payload->>'message' msg, created_at from notifications where type='idle_reminder' order by created_at desc limit 10;"
```

* Rerunning the job the same day does **not** duplicate reminders for the same task (daily de-dup works).

**Next:** wait for user

—

Mini training note: this job is stateless and idempotent-per-day thanks to the “no duplicate today” check against `notifications`. After you confirm it’s working, I’ll wire a platform cron (Render/Railway) and tie in “ball-in-court” so reminders mention the current ball owner. Also, paste your current `tasks`, `activity_log` (if any), and `notifications` table structures—I'll adapt the trigger and filters to your exact schema and fold in role-aware rules.
