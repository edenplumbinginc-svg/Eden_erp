[Mode: Execution]

Step: Emit `comment_added` events from the comment create endpoint using the same type-stable notify pattern.

Why it matters: With `task_created` + `status_changed` + `comment_added`, your automation layer can drive digests, reminders, and “last activity = ball owner” logic.

Inputs needed:

* File with `POST /api/tasks/:taskId/comments` (often `routes/comments.js` or inside `routes/tasks.js`).
* Existing `lib/notify.js` (type-stable insert with `::uuid` casts).

Command:

1. Wire the emitter into comment creation (adjust file/SQL/table names to your codebase):

```diff
// routes/comments.js  (or wherever you handle creating a comment)
+const { notify, actorFromHeaders } = require('../lib/notify');

router.post('/api/tasks/:taskId/comments', async (req, res, next) => {
  try {
    const { taskId } = req.params;
    const { body } = req.body; // text of the comment

    // 1) fetch task to get project_id and basic context
    const getTaskSql = `select id, project_id, title from tasks where id = $1::uuid`;
    const { rows: taskRows } = await req.pool.query(getTaskSql, [taskId]);
    if (!taskRows.length) return res.status(404).json({ error: 'Task not found' });
    const task = taskRows[0];

    // 2) create comment (use your actual table/columns)
    const insertSql = `
      insert into comments (task_id, body)
      values ($1::uuid, $2)
      returning id, task_id, body, created_at
    `;
    const { rows } = await req.pool.query(insertSql, [taskId, body]);
    const comment = rows[0];

+    // 3) fire-and-forget event bus emit
+    (async () => {
+      try {
+        const { actorEmail } = actorFromHeaders(req);
+        await notify(req.pool, {
+          type: 'comment_added',
+          projectId: task.project_id, // uuid
+          taskId: task.id,            // uuid
+          actorId: null,              // set to author id if you have one (cast type accordingly)
+          actorEmail: actorEmail || null,
+          payload: {
+            task_title: task.title,
+            comment_preview: String(comment.body || '').slice(0, 160),
+          },
+        });
+      } catch (e) {
+        console.warn('notify(comment_added) failed:', e.message);
+      }
+    })();

    return res.status(201).json(comment);
  } catch (err) {
    next(err);
  }
});
```

2. Ensure your `notify` insert uses explicit casts (already added earlier):

```js
// lib/notify.js (fragment)
const sql = `
  insert into notifications (type, project_id, task_id, actor_id, actor_email, payload)
  values ($1, $2::uuid, $3::uuid, $4::uuid, $5, $6::jsonb)
  returning id
`;
// If actor_id is not a UUID in your schema, change $4::uuid to the correct type or pass null.
```

3. Quick smoke test:

```bash
# Replace with a real task UUID
TASK_ID="<your-task-uuid>"
curl -s -X POST "http://localhost:3000/api/tasks/$TASK_ID/comments" \
  -H "Content-Type: application/json" \
  -H "X-User-Email: admin@edenmep.ca" \
  -d '{"body":"Hello from comment_added event test"}' | jq .

# Verify the notification landed
psql "$DATABASE_URL" -c "
  select type, project_id, task_id, actor_email,
         payload->>'task_title' as task_title,
         payload->>'comment_preview' as preview,
         to_char(created_at, 'YYYY-MM-DD HH24:MI:SS') as created_at
  from notifications
  where type = 'comment_added'
  order by id desc
  limit 5;
"
```

Success check:

* POST returns the created comment (201).
* A `notifications` row appears with `type = comment_added`, correct UUIDs, and a `comment_preview`.
* No warn logs like `notify(comment_added) failed`.

Next: wait for user

---

Training nugget: treat events as append-only facts with small payloads. Full comment text stays in `comments`; the event only carries context needed by consumers (digests, “ball last touched,” etc.). When you’re done, paste your current comment-create handler if names differ—I’ll inline-fix it to your exact schema.
