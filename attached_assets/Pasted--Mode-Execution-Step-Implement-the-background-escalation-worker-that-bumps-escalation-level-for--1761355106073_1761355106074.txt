[Mode: Execution]

Step: Implement the background escalation worker that bumps escalation_level for unacknowledged incidents and notifies Slack. (Backend layer → Jobs/Decision subsystem)

Why it matters: Incidents age into higher urgency automatically; later, CI Release Guard can gate on “no open critical incidents above L0”.

Inputs needed: Backend repo access, DB URL, existing Slack alert util (sendSlackAlert), owners helper.

Command (copy–paste):

lib/escalation.ts

import { sql, eq } from "drizzle-orm";
import { db } from "./db/client";
import { incidents } from "./db/schema/incidents";
import { sendSlackAlert } from "./alerts";
import { getOwnerForRoute } from "./owners";

const WARN_ACK_SLA_MIN = parseInt(process.env.ESC_WARN_ACK_MIN ?? "15", 10);
const CRIT_ACK_SLA_MIN = parseInt(process.env.ESC_CRIT_ACK_MIN ?? "5", 10);

async function notifyEscalation(row: typeof incidents.$inferSelect) {
  const snapshot = (row.owner as any) || null;
  const live = await getOwnerForRoute(row.route);
  const webhook =
    snapshot?.slack_webhook || live?.slack_webhook || process.env.SLACK_WEBHOOK_URL;

  await sendSlackAlert({
    webhook,
    title: `⏫ Escalation L${row.escalationLevel} — ${row.route} (${row.kind.toUpperCase()})`,
    text: [
      `Status: *${row.status}*  •  Severity: *${row.severity.toUpperCase()}*`,
      `Owner: *${snapshot?.owner || live?.owner || "unassigned"}*`,
      `First seen: ${row.firstSeen}  •  Last seen: ${row.lastSeen}`,
      `Incident key: \`${row.incidentKey}\``,
    ].join("\n"),
    buttons: [
      { text: "View in Velocity", url: `${process.env.APP_BASE_URL || "http://localhost:3000"}/velocity?incident=${row.id}` }
    ]
  });
}

export async function runEscalationTick(now = new Date()) {
  const rows = await db.execute(sql`
    SELECT *
    FROM incidents
    WHERE status = 'open'
      AND acknowledged_at IS NULL
      AND (
        EXTRACT(EPOCH FROM (${now.toISOString()}::timestamptz - first_seen)) / 60.0
      ) >= (
        CASE WHEN severity = 'critical' THEN ${CRIT_ACK_SLA_MIN}::int ELSE ${WARN_ACK_SLA_MIN}::int END
      ) * (escalation_level + 1)
  `);

  for (const row of rows as any[]) {
    const [updated] = await db.update(incidents)
      .set({ escalationLevel: row.escalation_level + 1, escalatedAt: now.toISOString() })
      .where(eq(incidents.id, row.id))
      .returning();
    await notifyEscalation(updated);
  }
  return rows.length;
}


Enable worker in the server (e.g., server.ts):

import { runEscalationTick } from "./lib/escalation";

if (process.env.ESCALATION_WORKER_ENABLED !== "false") {
  const intervalMs = parseInt(process.env.ESC_TICK_MS ?? "60000", 10);
  setInterval(() => runEscalationTick().catch(err => console.error("escalation tick failed", err)), intervalMs);
  console.log(`[esc] escalation worker ON @ ${intervalMs}ms`);
}


Optional test endpoint:

app.post("/ops/escalation/tick", async (_req, res) => {
  const n = await runEscalationTick();
  res.json({ escalated: n });
});


Success check:

# Seed a ripe incident for escalation
psql "$DATABASE_URL" -c "
UPDATE incidents
SET status='open', acknowledged_at=NULL, severity='critical',
    first_seen=now() - interval '10 minutes', escalation_level=0
WHERE incident_key = (SELECT incident_key FROM incidents LIMIT 1);
"

# Force a tick
curl -s -X POST http://localhost:3000/ops/escalation/tick | jq

# Verify bump
psql "$DATABASE_URL" -c "
SELECT incident_key, escalation_level, escalated_at
FROM incidents
ORDER BY escalated_at DESC
LIMIT 5;
"


Next: wait for user