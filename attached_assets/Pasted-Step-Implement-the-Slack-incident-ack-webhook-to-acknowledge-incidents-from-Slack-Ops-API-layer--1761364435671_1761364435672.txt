Step: Implement the Slack /incident-ack webhook to acknowledge incidents from Slack. (Ops API layer → ChatOps integration)

Why it matters: This turns your ACK into a one-liner in Slack, reusing your RBAC/HMAC stack safely.

Inputs needed: Backend repo access, Slack app (Signing Secret), existing OPS_HMAC_SECRET.

Command (copy–paste):

Env vars (add to Secrets)

SLACK_SIGNING_SECRET = your-slack-signing-secret
SLACK_APP_ID         = <optional, for logging>


Create routes/slack-incident-ack.ts

import type { Express, Request, Response } from "express";
import crypto from "crypto";
import fetch from "node-fetch"; // if not global
const text = (s:string)=>s;

function verifySlack(req: Request, signingSecret: string) {
  const ts = req.header("X-Slack-Request-Timestamp") || "";
  const sig = req.header("X-Slack-Signature") || "";
  // Basic replay window: 5 min
  if (Math.abs(Date.now()/1000 - Number(ts)) > 60*5) return false;
  const rawBody = (req as any).rawBody || (req as any)._raw || req.bodyRaw || "";
  const base = `v0:${ts}:${rawBody}`;
  const hash = `v0=` + crypto.createHmac("sha256", signingSecret).update(base).digest("hex");
  try {
    return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(sig));
  } catch { return false; }
}

function parseForm(body: string): Record<string,string> {
  return Object.fromEntries(
    body.split("&").map(p=>p.split("=").map(decodeURIComponent) as [string,string])
  );
}

export function mountSlackIncidentAck(app: Express) {
  // Capture raw body for Slack signature
  app.use("/slack/incident-ack", (req:any, _res, next)=>{
    let data = "";
    req.setEncoding("utf8");
    req.on("data",(c:string)=>{ data += c; });
    req.on("end", ()=>{ req.bodyRaw = data; next(); });
  });

  app.post("/slack/incident-ack", async (req: Request, res: Response) => {
    const signingSecret = process.env.SLACK_SIGNING_SECRET || "";
    if (!verifySlack(req, signingSecret)) {
      return res.status(401).send("invalid signature");
    }

    // Slack sends application/x-www-form-urlencoded
    const payload = parseForm((req as any).bodyRaw || "");
    const userName = payload.user_name || "slack-user";
    const textArg = (payload.text || "").trim(); // expects: incident UUID
    if (!textArg) {
      return res.json({ response_type: "ephemeral", text: "Usage: `/incident-ack <incident_id>`" });
    }

    // Prepare HMAC for internal ACK call
    const body = JSON.stringify({ reason: "slack-chatops-ack", actor: userName });
    const hmac = crypto.createHmac("sha256", process.env.OPS_HMAC_SECRET || "").update(body).digest("hex");

    // Call secured ops endpoint (same service)
    const base = process.env.APP_BASE_URL || "http://localhost:3000";
    const url = `${base}/ops/incidents/${encodeURIComponent(textArg)}/ack`;

    let ackOk = false, ackResp: any = null, err: any = null;
    try {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type":"application/json", "X-Signature": hmac, "Authorization": "Bearer slack-chatops" },
        body
      });
      const j = await r.json().catch(()=> ({}));
      ackOk = r.ok && j?.ok;
      ackResp = j;
      if (!ackOk) err = j?.error || `HTTP ${r.status}`;
    } catch (e:any) { err = e?.message || "fetch_failed"; }

    if (ackOk) {
      const inc = ackResp.incident;
      return res.json({
        response_type: "in_channel",
        text: text(`✅ Acknowledged incident *${inc.id}* (${inc.status}) by *${userName}*`)
      });
    } else {
      return res.json({
        response_type: "ephemeral",
        text: `❌ Failed to acknowledge: ${err ?? "unknown_error"}`
      });
    }
  });
}


Mount in server

// server.ts
import { mountSlackIncidentAck } from "./routes/slack-incident-ack";
mountSlackIncidentAck(app);


Slack slash command setup

Command: /incident-ack

Request URL: https://<YOUR-STAGING_HOST>/slack/incident-ack

Method: POST

Usage hint: /incident-ack <incident_id>

Save, then Install app to your workspace.

Success check:

In Slack: run /incident-ack <INCIDENT_UUID>

Expect: ✅ Acknowledged incident <id> by <your_slack_username>

DB row shows status='acknowledged', acknowledged_at set.

Next: wait for user