[Mode: Execution]

Step: Ship the guarded Create Project page (UI + RBAC) and wire the “New Project” button to it.

Why it matters: Your POST /api/projects is live and permissioned. This completes the vertical slice end-to-end: guarded route → form → API → redirect.

Inputs needed: Replit repo; routes file; Projects list component; your existing services/api.js.

Command (Layers: Frontend + RBAC — route+form)

Add a post() helper if missing:

// apps/coordination_ui/src/services/api.js
export async function post(url, body) {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...devHeaders },
    body: JSON.stringify(body),
  });
  if (!res.ok) {
    const err = await res.json().catch(() => ({}));
    throw { status: res.status, ...err };
  }
  return res.json();
}


Create the page: apps/coordination_ui/src/pages/ProjectCreate.jsx

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
// use relative imports to avoid alias issues
import { post } from "../services/api";

const codeRe = /^[A-Z0-9-]{1,12}$/;

export default function ProjectCreate() {
  const nav = useNavigate();
  const [f, setF] = useState({ name: "", code: "", client: "", startDate: "", notes: "" });
  const [err, setErr] = useState({});
  const [busy, setBusy] = useState(false);

  function set(field) {
    return (e) => setF((s) => ({ ...s, [field]: e.target.value }));
  }

  function validate() {
    const e = {};
    if (!f.name || f.name.length > 80) e.name = "Name is required (≤80).";
    if (!codeRe.test(f.code)) e.code = "Code A–Z, 0–9, dash, ≤12.";
    if (f.client && f.client.length > 120) e.client = "Client ≤120.";
    if (f.notes && f.notes.length > 1000) e.notes = "Notes ≤1000.";
    setErr(e);
    return Object.keys(e).length === 0;
  }

  async function submit(e) {
    e.preventDefault();
    if (!validate()) return;
    setBusy(true);
    try {
      const payload = {
        name: f.name.trim(),
        code: f.code.trim(),
        client: f.client.trim() || undefined,
        startDate: f.startDate ? new Date(f.startDate).toISOString() : undefined,
        notes: f.notes.trim() || undefined,
      };
      const { item } = await post("/api/projects", payload);
      // optional: toast “Project created”
      nav(`/project/${item.id}`);
    } catch (ex) {
      if (ex.status === 409) {
        setErr({ code: "Code already exists." });
      } else if (ex.status === 400 && ex.details) {
        // backend zod details → surface first message
        setErr({ form: "Fix highlighted fields." });
      } else if (ex.status === 403) {
        setErr({ form: "You don’t have permission to create projects." });
      } else {
        setErr({ form: "Server error. Try again." });
      }
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="p-4 max-w-xl">
      <h1 className="text-xl font-semibold mb-3">New Project</h1>
      {err.form && <div className="mb-2 text-sm text-red-600">{err.form}</div>}
      <form onSubmit={submit} className="grid gap-3">
        <label className="grid gap-1">
          <span>Name *</span>
          <input value={f.name} onChange={set("name")} className="border rounded p-2" />
          {err.name && <small className="text-red-600">{err.name}</small>}
        </label>

        <label className="grid gap-1">
          <span>Code *</span>
          <input value={f.code} onChange={set("code")} className="border rounded p-2" placeholder="EWR-01" />
          {err.code && <small className="text-red-600">{err.code}</small>}
        </label>

        <label className="grid gap-1">
          <span>Client</span>
          <input value={f.client} onChange={set("client")} className="border rounded p-2" />
          {err.client && <small className="text-red-600">{err.client}</small>}
        </label>

        <label className="grid gap-1">
          <span>Start Date</span>
          <input type="date" value={f.startDate} onChange={set("startDate")} className="border rounded p-2" />
        </label>

        <label className="grid gap-1">
          <span>Notes</span>
          <textarea value={f.notes} onChange={set("notes")} className="border rounded p-2" rows={4} />
          {err.notes && <small className="text-red-600">{err.notes}</small>}
        </label>

        <div className="flex gap-2">
          <button disabled={busy} className="px-3 py-2 border rounded">
            {busy ? "Creating..." : "Create Project"}
          </button>
          <button type="button" onClick={() => history.back()} className="px-3 py-2 border rounded">
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
}


Guard the route: open your routes file (e.g., apps/coordination_ui/src/App.jsx) and add:

import { Routes, Route } from "react-router-dom";
import RoutePermission from "./components/RoutePermission";
import ProjectCreate from "./pages/ProjectCreate";

// …
<Route
  path="/projects/new"
  element={
    <RoutePermission resource="projects" action="create">
      <ProjectCreate />
    </RoutePermission>
  }
/>


Add the guarded button to your Projects list header:

// apps/coordination_ui/src/components/ProjectList.jsx (or your list page)
import { Link } from "react-router-dom";
import RequirePermission from "../components/RequirePermission";

// inside header toolbar:
<RequirePermission resource="projects" action="create" fallback={null}>
  <Link to="/projects/new" className="px-3 py-1 border rounded">New Project</Link>
</RequirePermission>


Success check:

As Admin: “New Project” button appears → /projects/new renders. Valid submission creates the project and redirects to its detail page.

As Viewer: Button hidden; visiting /projects/new shows your 403 page (route guard).

Duplicate code → inline “Code already exists.”; invalid code → inline validation message.

Next: wait for user

Tiny dev lesson: this step locks the whole Create slice without future churn—UI validates the same rules the backend enforces, RBAC hides and blocks, and the redirect proves the contract. When this compiles, we’ll do the Edit form using the same patterns in one pass.