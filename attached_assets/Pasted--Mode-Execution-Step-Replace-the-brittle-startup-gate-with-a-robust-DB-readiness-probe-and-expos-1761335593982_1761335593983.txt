[Mode: Execution]

Step: Replace the brittle startup gate with a robust DB readiness probe and expose /ops/ready (readiness) + /ops/health (detailed JSON). Keep Velocity Metrics Core intact. (Layer: Velocity → Health Core)

Why it matters: Prevents boot flapping and “half-alive” instances by only accepting traffic once the DB is truly reachable, and gives ops a single source of truth for health.

Inputs needed:

Access to your PostgreSQL client (pg Pool or your Drizzle/Knex adapter)

server.js (Express entry)


Command:

1. Create lib/health.js



// lib/health.js — Velocity/Health Core
const DEFAULT_OPTS = {
  probeIntervalMs: 10_000,
  startupTimeoutMs: 60_000,
  backoffMs: 500,
  backoffMaxMs: 5_000,
};

function jitter(ms) { return Math.min(ms * 1.5, 30_000); }

function ms() { return Date.now(); }

async function probeDb(db) {
  const t0 = ms();
  // Support pg Pool, Drizzle (pg), or Knex. Adapt SELECT 1 syntax to your client.
  // For pg/Drizzle this works:
  await db.query?.(`SELECT 1`) ?? db.execute?.(`SELECT 1`);
  return ms() - t0;
}

function makeHealth({ db, opts = {} }) {
  const cfg = { ...DEFAULT_OPTS, ...opts };
  let ready = false;
  let last = { at: null, ok: false, db_latency_ms: null, error: null, uptime_ms: 0 };

  async function runProbe() {
    try {
      const latency = await probeDb(db);
      last = { at: new Date().toISOString(), ok: true, db_latency_ms: latency, error: null, uptime_ms: process.uptime() * 1000 };
      ready = true;
    } catch (e) {
      last = { at: new Date().toISOString(), ok: false, db_latency_ms: null, error: String(e.message || e), uptime_ms: process.uptime() * 1000 };
      ready = false;
    }
  }

  // background ticker
  setInterval(runProbe, cfg.probeIntervalMs).unref();

  // startup gate with exponential backoff (bounded)
  async function waitUntilReady() {
    const start = ms();
    let backoff = cfg.backoffMs;
    // first attempt immediately
    await runProbe();
    while (!ready && ms() - start < cfg.startupTimeoutMs) {
      await new Promise(r => setTimeout(r, backoff));
      await runProbe();
      backoff = Math.min(jitter(backoff * 2), cfg.backoffMaxMs);
    }
    if (!ready) throw new Error(`DB not ready after ${cfg.startupTimeoutMs}ms`);
  }

  function liveness() { return true; } // process is up; don’t depend on externals

  function readiness() { return ready; } // safe to serve traffic

  function snapshot() {
    return {
      service: "eden-erp-backend",
      env: process.env.SENTRY_ENV || process.env.NODE_ENV || "dev",
      generated_at: new Date().toISOString(),
      liveness: liveness(),
      readiness: readiness(),
      db: { ok: last.ok, latency_ms: last.db_latency_ms, error: last.error },
      uptime_ms: last.uptime_ms,
      version: process.env.RELEASE_SHA || null,
      build_time: process.env.BUILD_TIME || null,
    };
  }

  return { waitUntilReady, liveness, readiness, snapshot };
}

module.exports = { makeHealth };

2. Wire into server.js (before routes):



// Health Core wiring (keep Metrics Core as-is)
const { makeHealth } = require("./lib/health");

// If you use 'pg' Pool:
const { Pool } = require("pg");
const pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });

const health = makeHealth({ db: pool });

// Block serving until DB ready (startup gate)
await health.waitUntilReady(); // if using CommonJS without top-level await, wrap server start in an async IIFE

// Liveness & readiness endpoints
app.get("/ops/live", (_req, res) => res.status(200).send("OK"));
app.get("/ops/ready", (_req, res) => {
  return health.readiness() ? res.status(200).send("READY") : res.status(503).send("NOT_READY");
});
app.get("/ops/health", (_req, res) => {
  res.setHeader("Cache-Control", "no-store");
  res.json(health.snapshot());
});

> If your file doesn’t support top-level await, start the server like:



(async () => {
  try {
    await health.waitUntilReady();
    app.listen(process.env.PORT || 3000, () => console.log("server up"));
  } catch (e) {
    console.error("Startup failed:", e);
    process.exit(1); // fail fast on cold start if DB unreachable
  }
})();

Success check:

Cold start: the server only begins listening after the DB answers SELECT 1. If DB is down, process exits with a clear error.

GET /ops/ready returns 200 READY once probes pass; otherwise 503 NOT_READY.

GET /ops/health returns JSON with { db.ok, db.latency_ms, readiness, liveness, version, build_time }.


Next: wait for user.