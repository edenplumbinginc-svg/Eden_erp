[Mode: Execution]

**Step:** Fix the TLS error **permanently** with a safe code-level flag (no more NODE_TLS hacks), then restart.

**Why it matters:** We solved creds. What’s left is the TLS chain on Replit. Adding an explicit `DB_SSL_REJECT_UNAUTHORIZED` flag in code makes this stable and under your control (dev only), so we stop circling.

**Inputs needed:** Edit access to `lib/config-db.js`, Replit Secrets.

**Command (copy–paste):**

```bash
# 1) Patch lib/config-db.js to respect a safe TLS flag
cat > /tmp/patch-db-ssl.js <<'JS'
const fs = require('fs');
const path = 'lib/config-db.js';
let s = fs.readFileSync(path, 'utf8');

// Insert/replace ssl options for pg Pool/Client
if (!s.includes('DB_SSL_REJECT_UNAUTHORIZED')) {
  s = s.replace(
    /new\s+Pool\(\s*{\s*([\s\S]*?)connectionString:\s*process\.env\.DATABASE_URL\s*,?/m,
    (m) => {
      const inject = `const allowInsecure = String(process.env.DB_SSL_REJECT_UNAUTHORIZED || '').toLowerCase() === 'false';
const ssl = allowInsecure ? { rejectUnauthorized: false } : { rejectUnauthorized: true };

${m}`;
      return inject;
    }
  );

  // ensure we pass ssl in the Pool config
  s = s.replace(/new\s+Pool\(\s*{\s*([\s\S]*?)\}\s*\)/m, (m) => {
    // if ssl already present, leave; else add
    if (/ssl\s*:/.test(m)) return m;
    return m.replace(/\}\s*\)$/, `, ssl }\)`); // add "ssl" into the object
  });
  fs.writeFileSync(path, s);
  console.log('✅ Updated lib/config-db.js to use DB_SSL_REJECT_UNAUTHORIZED flag.');
} else {
  console.log('ℹ️ TLS flag logic already present in lib/config-db.js');
}
JS

node /tmp/patch-db-ssl.js

# 2) Enable the flag for dev (so TLS errors stop now)
# Use a Secret later; for this session we export and also put in .env so it persists
export DB_SSL_REJECT_UNAUTHORIZED=false
grep -q '^DB_SSL_REJECT_UNAUTHORIZED=' .env || echo 'DB_SSL_REJECT_UNAUTHORIZED=false' >> .env

# 3) Restart and check logs
pkill -f "node server" 2>/dev/null || true
node server.js > /tmp/server.log 2>&1 & sleep 3
curl -s http://localhost:3000/health && echo
tail -50 /tmp/server.log
```

**Success check:**

* Logs no longer show `self-signed certificate in certificate chain`.
* No “degraded mode” line.

If clean, run the smoke to prove end-to-end:

```bash
bash -lc './prod-smoke.sh'
```

Expected last line:

```
✅✅✅ PASS: transactional writes & event bus verified.
```

**Next:** wait for user

Quick reassurance: we’re not looping aimlessly. We finished creds (fixed), now we’re locking TLS behavior in code so this class of error can’t derail you again. After this passes, we’ll flip the flag back to strict in prod and (later) pin Supabase’s CA cleanly.
