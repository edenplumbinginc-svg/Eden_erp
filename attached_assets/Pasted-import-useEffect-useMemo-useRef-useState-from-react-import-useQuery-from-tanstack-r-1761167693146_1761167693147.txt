import { useEffect, useMemo, useRef, useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link } from "react-router-dom";
import { apiService } from "../services/api";
import { useToaster } from "./Toaster";

export default function NotificationsBell() {
  const [open, setOpen] = useState(false);
  const lastSeen = useRef(0);
  const { push } = useToaster();

  const { data: items = [], refetch } = useQuery({
    queryKey: ["recent_notifications"],
    queryFn: () => apiService.listRecentNotifications(),
    refetchInterval: 30_000,
  });

  useEffect(() => {
    if (!items.length) return;
    const latestTs = Math.max(...items.map(n => +new Date(n.created_at)));
    if (lastSeen.current && latestTs > lastSeen.current) {
      push("success", "New notifications received");
    }
    lastSeen.current = latestTs;
  }, [items, push]);

  const unreadCount = useMemo(() => items.filter(n => !n.read_at).length, [items]);

  const handleMarkAsRead = async (id) => {
    try {
      await apiService.markNotificationRead(id);
      push("success", "Notification marked as read");
      refetch();
    } catch {
      push("error", "Failed to mark notification as read");
    }
  };

  const handleMarkAllAsRead = async () => {
    try {
      await apiService.markAllNotificationsRead();
      push("success", "All notifications marked as read");
      refetch();
    } catch {
      push("error", "Failed to mark all as read");
    }
  };

  // Group notifications by type
  const grouped = useMemo(() => {
    const groups = {};
    for (let n of items) {
      const t = n.type || "other";
      if (!groups[t]) groups[t] = [];
      groups[t].push(n);
    }
    return groups;
  }, [items]);

  const typeOrder = ["ball_handoff", "comment_added", "status_changed"];
  const groupEntries = Object.entries(grouped).sort(([a], [b]) => {
    const ai = typeOrder.indexOf(a), bi = typeOrder.indexOf(b);
    if (ai === -1 && bi === -1) return a.localeCompare(b);
    if (ai === -1) return 1;
    if (bi === -1) return -1;
    return ai - bi;
  });

  const TYPE_ICON = {
    ball_handoff: "🏀",
    comment_added: "💬",
    status_changed: "📊",
    task_created: "✨",
    task_assigned: "👤",
    task_overdue: "⏰",
  };
  const TYPE_LABEL = {
    ball_handoff: "Ball Handoff",
    comment_added: "Comment",
    status_changed: "Status Change",
    task_created: "Task Created",
    task_assigned: "Task Assigned",
    task_overdue: "Task Overdue",
  };

  return (
    <div className="relative">
      <button 
        className="relative px-3 py-1 border rounded text-sm" 
        onClick={() => setOpen(o => !o)}
      >
        🔔 Notifications
        {unreadCount > 0 && (
          <span className="ml-2 inline-block text-xs bg-amber-500 text-white rounded-full px-2">
            {unreadCount}
          </span>
        )}
      </button>

      {open && (
        <div className="absolute right-0 mt-2 w-96 max-h-96 overflow-auto bg-white border rounded shadow z-40">
          {/* Panel Header */}
          <div className="flex items-center justify-between px-3 py-2 border-b">
            <span className="font-semibold text-sm">Recent Notifications</span>
            <div className="flex gap-2">
              {unreadCount > 0 && (
                <button className="text-xs underline text-blue-600 hover:text-blue-800" onClick={handleMarkAllAsRead}>
                  Mark all read
                </button>
              )}
              <button className="text-xs underline" onClick={() => refetch()}>Refresh</button>
            </div>
          </div>

          {/* Notification Groups */}
          {items.length === 0 ? (
            <div className="p-3 text-sm text-gray-500">No notifications.</div>
          ) : (
            groupEntries.map(([type, notifs]) => (
              <div key={type}>
                <div className="px-3 py-2 font-medium bg-gray-100 flex items-center gap-2">
                  <span>{TYPE_ICON[type] || "🔔"}</span>
                  <span>{TYPE_LABEL[type] || type}</span>
                </div>
                <ul className="divide-y">
                  {notifs.map(n => {
                    const isUnread = !n.read_at;
                    return (
                      <li 
                        key={n.id} 
                        className={`p-3 text-sm flex items-start justify-between gap-3 ${isUnread ? "bg-blue-50" : "bg-white"}`}
                      >
                        <div className="flex-1">
                          <div className={isUnread ? "font-bold" : "font-medium"}>
                            {formatNotificationText(n)}
                          </div>
                          <div className="text-xs text-gray-600 mt-1">
                            {new Date(n.created_at).toLocaleString()}
                          </div>
                        </div>
                        <div className="flex flex-col gap-1">
                          {n.task_id && (
                            <Link 
                              to={`/task/${n.task_id}`} 
                              className="px-2 py-1 border rounded text-xs bg-white hover:bg-gray-50 text-center"
                              onClick={() => setOpen(false)}
                            >
                              Open
                            </Link>
                          )}
                          {isUnread && (
                            <button 
                              className="px-2 py-1 border rounded text-xs bg-white hover:bg-gray-50"
                              onClick={() => handleMarkAsRead(n.id)}
                            >
                              ✓ Read
                            </button>
                          )}
                        </div>
                      </li>
                    );
                  })}
                </ul>
              </div>
            ))
          )}
        </div>
      )}
    </div>
  );
}

// Helper to format notification text (preserves emoji icons per type)
function formatNotificationText(notification) {
  const { type, payload, actor_email } = notification;
  const actorName = actor_email ? actor_email.split('@')[0] : 'Someone';
  switch(type) {
    case "ball_handoff":
      return `🏀 Task handed to ${payload.toDepartment}: ${payload.title}`;
    case "comment_added":
      return `💬 ${actorName} commented on: ${payload.title}`;
    case "status_changed":
      return `📊 Task "${payload.title}" changed to ${payload.newStatus}`;
    case "task_created":
      return `✨ New task created: ${payload.title || 'Untitled'}`;
    case "task_assigned":
      return `👤 Task assigned to you: ${payload.title || 'Untitled'}`;
    case "task_overdue":
      return `⏰ Task overdue: ${payload.title || 'Untitled'}`;
    default:
      return payload.title || type || "Notification";
  }
}
