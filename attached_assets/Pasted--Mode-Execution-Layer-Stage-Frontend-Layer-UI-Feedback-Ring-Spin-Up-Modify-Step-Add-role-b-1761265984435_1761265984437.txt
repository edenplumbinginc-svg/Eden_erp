[Mode: Execution]
Layer/Stage: Frontend Layer → UI Feedback Ring | Spin-Up → Modify
Step: Add role badge in header, view-only hints where actions are hidden, memoized permission checks, and lightweight telemetry for cache hits/misses.
Why it matters: Users instantly see their access level, understand why controls are missing, and you cut re-renders + confusion while gaining observability.
1) Role badge in header
Files/Changes
apps/coordination_ui/src/components/RoleBadge.jsx
Copy code
Jsx
import React from "react";
import { useAuthContext } from "../hooks/AuthProvider"; // uses your existing context

const LABELS = {
  admin: "Admin",
  operations: "Operations",
  contributor: "Contributor",
  viewer: "Viewer",
};

export default function RoleBadge() {
  const { roles = [] } = useAuthContext();
  const primary = roles[0] || "viewer";
  const label = LABELS[primary] || primary;

  return (
    <span
      title={`Signed in as ${label}`}
      className="inline-flex items-center gap-2 rounded-full border px-3 py-1 text-xs font-medium"
      style={{ opacity: 0.9 }}
      data-cy="role-badge"
    >
      <span
        className="h-2 w-2 rounded-full"
        style={{
          display: "inline-block",
          background:
            primary === "admin" ? "#ef4444" :
            primary === "operations" ? "#f59e0b" :
            primary === "contributor" ? "#10b981" :
            "#3b82f6",
        }}
      />
      {label}
    </span>
  );
}
Inject into header (e.g., apps/coordination_ui/src/layouts/Header.jsx)
Copy code
Jsx
import RoleBadge from "../components/RoleBadge";
// ...
export default function Header() {
  return (
    <header className="flex items-center justify-between px-4 py-2 border-b">
      <div className="font-semibold">Eden ERP</div>
      <div className="flex items-center gap-3">
        <RoleBadge />
      </div>
    </header>
  );
}
Layer/Stage update: Frontend → Modify ✅
2) View-only “why hidden” hint
apps/coordination_ui/src/components/PermissionGate.jsx
Copy code
Jsx
import React from "react";
import { useAuthContext } from "../hooks/AuthProvider";

export default function PermissionGate({ perm, children, fallback = null, hint = "View-only: missing permission" }) {
  const { permissions = [] } = useAuthContext(); // array of slugs
  const allowed = permissions.includes(perm);

  if (allowed) return children;

  if (fallback !== null) return fallback;

  // Subtle inline hint when no fallback is provided
  return (
    <span className="text-xs text-gray-500 select-none" title={hint} data-cy={`hint-${perm.replace(':','-')}`}>
      {/* reserved space to reduce layout shift */}
    </span>
  );
}
Use it anywhere you conditionally render actions
Copy code
Jsx
import PermissionGate from "../components/PermissionGate";

<PermissionGate perm="tasks:create" fallback={null} hint="You need tasks:create">
  <button className="btn-primary">New Task</button>
</PermissionGate>
Layer/Stage update: Frontend → Modify ✅
3) Memoized permission check (context)
apps/coordination_ui/src/hooks/AuthProvider.jsx (add a memoized helper in the value you already expose)
Copy code
Jsx
import React, { createContext, useContext, useMemo } from "react";
// ... existing imports

const AuthCtx = createContext(null);

export function AuthProvider({ children }) {
  // existing state from your implementation:
  // const [roles, setRoles] = useState([]);
  // const [permissions, setPermissions] = useState([]); // array of slugs

  // ... your existing logic that populates roles/permissions + cache

  const permSet = useMemo(() => new Set(permissions || []), [permissions]);

  const hasPermission = useMemo(
    () => (p) => permSet.has(p),
    [permSet]
  );

  const value = useMemo(
    () => ({ roles, permissions, hasPermission }),
    [roles, permissions, hasPermission]
  );

  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>;
}

export const useAuthContext = () => useContext(AuthCtx);
Refactor usages to read hasPermission
Copy code
Jsx
const { hasPermission } = useAuthContext();
{hasPermission("tasks:create") && <button className="btn-primary">New Task</button>}
Layer/Stage update: Frontend → Modify ✅
4) Telemetry (cache hit/miss + latency)
apps/coordination_ui/src/lib/telemetry.js
Copy code
Js
const KEY = "eden.telemetry.v1";
function load() {
  try { return JSON.parse(localStorage.getItem(KEY)) || { hits:0, misses:0, lastMs:null }; }
  catch { return { hits:0, misses:0, lastMs:null }; }
}
function save(data) { try { localStorage.setItem(KEY, JSON.stringify(data)); } catch {} }

export function logCacheHit() {
  const d = load(); d.hits += 1; save(d);
}
export function logCacheMiss(ms) {
  const d = load(); d.misses += 1; d.lastMs = ms; save(d);
}
export function readTelemetry() { return load(); }
export function resetTelemetry() { save({ hits:0, misses:0, lastMs:null }); }
Wire telemetry into your cache/bootstrap
In permissionsCache.js when you successfully return cached data: logCacheHit()
After network fetch completes: logCacheMiss(elapsedMs)
Example (inside your background refresh):
Copy code
Js
import { logCacheHit, logCacheMiss } from "../lib/telemetry";

// when you serve from cache:
logCacheHit();

// when you fetch fresh:
const t0 = performance.now();
const fresh = await fetchPermissions(jwt);
const dt = Math.round(performance.now() - t0);
logCacheMiss(dt);
Quick console probe
Copy code
Js
// Browser console
localStorage.getItem('eden.telemetry.v1');
// { hits: X, misses: Y, lastMs: Z }
Layer/Stage update: Frontend → Modify ✅ → Stable
Success check
Header shows a colored role badge consistent with current primary role.
Hidden actions no longer “mysteriously disappear”; the hint target exists (no layout jump) and a tooltip explains why.
hasPermission now stable (fewer re-renders when unrelated state updates).
eden.telemetry.v1 accumulates hits/misses/lastMs.
Progress Circling
Frontend Layer: Modify → ✅ Stable
RBAC Layer: Observe (no changes)
Integration Layer: ✅ Stable (no duplicate calls; clean UI gating)
Optimization Layer: Ring 2 complete
Next (tell, not ask)
Layer/Stage: Backend Layer → Optimization | Spin-Up → Modify
Command: Add a minimal /api/me/permissions/etag endpoint to return a hash (e.g., sha1(roles+perms) or updated_at watermark). The client compares ETag before re-fetch; if unchanged, skip payload.
If you’re ready, I’ll drop the exact Express + Drizzle snippet for the ETag route and wire the client to use If-None-Match → 304 Not Modified for even leaner traffic.