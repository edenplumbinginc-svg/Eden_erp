Step: Add a server-side alarms endpoint /ops/alarms that flags hot routes now (err% ≥5 in 1m, or p95 regression ≥20% AND ≥30ms using last/prev 3 buckets). Backend-only; zero infra. (Layer: Velocity → Alerts Core)

Why it matters: You don’t have to stare at graphs—this gives a machine-readable list of what’s on fire right now for the Velocity UI or future webhooks.

Inputs needed:

lib/metrics.js

server.js

Command:

Patch lib/metrics.js — add alarm evaluation using existing data

// lib/metrics.js
// ...existing code...
const WINDOW_SIZES = [60_000, 300_000, 900_000];
const TREND_SPAN_MS = 300_000;
const TREND_BUCKET_MS = 10_000;

// keep existing helpers...

function bucketize(points, spanMs, bucketMs) {
  const nowTs = Date.now();
  const start = nowTs - spanMs;
  const bucketCount = Math.ceil(spanMs / bucketMs);
  const buckets = Array.from({ length: bucketCount }, (_, i) => ({
    t: start + i * bucketMs,
    count: 0,
    durs: [],
    ok: 0,
  }));
  let idx = 0;
  while (idx < points.length && points[idx].t < start) idx++;
  for (; idx < points.length; idx++) {
    const p = points[idx];
    const bi = Math.min(bucketCount - 1, Math.floor((p.t - start) / bucketMs));
    if (bi >= 0) {
      buckets[bi].count++;
      buckets[bi].durs.push(p.dur_ms);
      if (p.ok) buckets[bi].ok++;
    }
  }
  return buckets.map(b => ({
    t: new Date(b.t).toISOString(),
    rps: +(b.count / (bucketMs / 1000)).toFixed(3),
    p95_ms: b.durs.length ? Math.round(percentile(b.durs, 0.95)) : null,
    err_rate: b.count ? +(((b.count - b.ok) / b.count) * 100).toFixed(2) : 0,
  }));
}

function makeMetrics() {
  const perRoute = new Map();

  function routeKey(req) { return `${req.method} ${req.route?.path || req.path}`; }

  function ensureWindowsFor(key) {
    if (!perRoute.has(key)) perRoute.set(key, WINDOW_SIZES.map(ms => makeWindow(ms)));
    return perRoute.get(key);
  }

  function tap(req, _res, dur_ms, ok) {
    const k = routeKey(req);
    const wins = ensureWindowsFor(k);
    wins.forEach(w => record(w, dur_ms, ok));
  }

  function summarize(win) {
    const pts = win.points;
    const n = pts.length;
    if (!n) return { count: 0, rps: 0, p50_ms: null, p95_ms: null, err_rate: 0 };
    const dur = pts.map(p=>p.dur_ms);
    const okCount = pts.filter(p=>p.ok).length;
    const span_s = win.ms / 1000;
    return {
      count: n,
      rps: +(n / span_s).toFixed(3),
      p50_ms: Math.round(percentile(dur, 0.50)),
      p95_ms: Math.round(percentile(dur, 0.95)),
      err_rate: +(((n - okCount) / n) * 100).toFixed(2),
    };
  }

  function snapshot() {
    const out = {};
    for (const [k, wins] of perRoute.entries()) {
      out[k] = {
        "1m": summarize(wins[0]),
        "5m": summarize(wins[1]),
        "15m": summarize(wins[2]),
      };
    }
    return {
      service: "eden-erp-backend",
      env: process.env.SENTRY_ENV || process.env.NODE_ENV || "dev",
      generated_at: new Date().toISOString(),
      routes: out,
    };
  }

  function trends() {
    const out = {};
    for (const [k, wins] of perRoute.entries()) {
      const w5 = wins[1];
      out[k] = {
        span_ms: TREND_SPAN_MS,
        bucket_ms: TREND_BUCKET_MS,
        series: bucketize(w5.points, TREND_SPAN_MS, TREND_BUCKET_MS),
      };
    }
    return {
      service: "eden-erp-backend",
      env: process.env.SENTRY_ENV || process.env.NODE_ENV || "dev",
      generated_at: new Date().toISOString(),
      routes: out,
    };
  }

  // --- NEW: alarms() computes current hot routes
  function alarms() {
    const nowIso = new Date().toISOString();
    const snap = snapshot();
    const tr = trends();
    const items = [];

    for (const route of Object.keys(snap.routes)) {
      const one = snap.routes[route]["1m"] || {};
      const series = tr.routes[route]?.series || [];
      const last6 = series.slice(-6);
      const last3 = last6.slice(-3).map(b => b?.p95_ms).filter(v => v != null);
      const prev3 = last6.slice(0, 3).map(b => b?.p95_ms).filter(v => v != null);
      const avg = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : null;
      const aLast = avg(last3);
      const aPrev = avg(prev3);
      const regress_abs = (aLast!=null && aPrev!=null) ? (aLast - aPrev) : 0;
      const regress_pct = (aLast!=null && aPrev>0) ? +(((aLast - aPrev)/aPrev)*100).toFixed(1) : 0;

      // Rule A: high error rate in the last minute
      if (one.err_rate >= 5 && one.count >= 5) {
        items.push({
          route,
          kind: "error_rate",
          severity: one.err_rate >= 20 ? "critical" : "warning",
          since: nowIso,
          evidence: { err_rate_1m: one.err_rate, samples_1m: one.count },
          hint: "Investigate recent errors; click Sentry link for this route.",
        });
      }

      // Rule B: regression in p95 (last3 vs prev3)
      if (aLast!=null && aPrev!=null && regress_abs >= 30 && regress_pct >= 20) {
        items.push({
          route,
          kind: "p95_regress",
          severity: regress_pct >= 50 ? "critical" : "warning",
          since: nowIso,
          evidence: { p95_prev3_ms: Math.round(aPrev), p95_last3_ms: Math.round(aLast), regress_abs_ms: Math.round(regress_abs), regress_pct },
          hint: "Latency increased; check recent deploys, DB, or upstreams.",
        });
      }
    }

    return {
      service: "eden-erp-backend",
      env: process.env.SENTRY_ENV || process.env.NODE_ENV || "dev",
      generated_at: nowIso,
      alarms: items,
    };
  }

  return { tap, snapshot, trends, alarms };
}

module.exports = { makeMetrics };


Wire the endpoint in server.js

// after other /ops routes
app.get("/ops/alarms", (_req, res) => {
  res.setHeader("Cache-Control", "no-store");
  res.json(metrics.alarms());
});


Success check:

# Warm up traffic first (hit a few routes), then:
curl -s http://localhost:3000/ops/alarms | python3 -m json.tool

# Expected:
# {
#   "service": "eden-erp-backend",
#   "env": "dev",
#   "generated_at": "...",
#   "alarms": [
#     {
#       "route": "GET /api/foo",
#       "kind": "p95_regress",
#       "severity": "warning",
#       "since": "...",
#       "evidence": { "p95_prev3_ms": 120, "p95_last3_ms": 180, "regress_abs_ms": 60, "regress_pct": 50.0 },
#       "hint": "Latency increased; check recent deploys, DB, or upstreams."
#     },
#     {
#       "route": "GET /api/bar",
#       "kind": "error_rate",
#       "severity": "critical",
#       "since": "...",
#       "evidence": { "err_rate_1m": 24.0, "samples_1m": 37 },
#       "hint": "Investigate recent errors; click Sentry link for this route."
#     }
#   ]
# }


Next: wait for user.