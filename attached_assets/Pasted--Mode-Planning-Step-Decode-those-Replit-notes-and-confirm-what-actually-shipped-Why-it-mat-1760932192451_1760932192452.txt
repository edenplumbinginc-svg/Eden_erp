[Mode: Planning]

Step: Decode those Replit notes and confirm what actually shipped.

Why it matters: You saw a bunch of terse agent logs; here’s the plain-English meaning so you know what changed and what to do next.

Inputs needed: none.

Command:

* Read this quick map, then we’ll run one verification step.

Success check: You can explain back what “comment_added events” are and why the restart matters.

---

## What “implement `comment_added` events” means

* Every time someone posts a comment on a task (`POST /api/tasks/:taskId/comments`), your server now **emits an event** into the `notifications` table with:

  * `type: "comment_added"`
  * `project_id` (UUID), `task_id` (UUID)
  * `actor_email` (from headers)
  * `payload` with a small `comment_preview` (first 160 chars) and the task title
* This uses the same **type-stable notify pattern** we added for `task_created` and `status_changed`:

  * SQL casts like `project_id = $2::uuid`, `payload = $6::jsonb` to avoid driver confusion.
* Why you care: this powers digests (“what happened today”), comment alerts, and “ball last touched” logic—without changing your main APIs.

## What “Checkpoint made / 21 actions / +45 −28” means

* That’s the agent’s change summary: it created/edited code, ran tests, and committed.
* The “Improve the way users can navigate through the system” line is a separate small change (e.g., router links, breadcrumbs, or navigation buttons). It’s unrelated to the event bus, just shipped in the same burst.

## Why the workspace restart note keeps popping up

* Your DB columns were migrated to UUIDs. The Node pg connection pool sometimes **caches old column types** until the process is fully restarted.
* A **full Replit workspace restart** clears those cached types. After that, the app-path inserts stop complaining about “bigint vs uuid”.

---

[Mode: Execution]

Step: Verify all three events via the **API path** after a full workspace restart.

Why it matters: Confirms the event bus works end-to-end (not just by direct SQL).

Inputs needed:

* Replit workspace access
* One real `PROJECT_ID` (copy from `/api/projects`)

Command:

1. Full restart in Replit:

   * Menu → Workspace → **Restart workspace**
   * When back up, start the backend (your usual `npm run dev` or `node server.js`).

2. Run this exact smoke (replace `PROJECT_ID`):

```bash
# Health
curl -s http://localhost:3000/health || curl -s http://localhost:3000/api/health

# Create task -> task_created
PROJECT_ID="<YOUR_PROJECT_UUID>"
TASK_ID=$(curl -s -X POST "http://localhost:3000/api/projects/$PROJECT_ID/tasks" \
  -H "Content-Type: application/json" \
  -H "X-User-Email: admin@edenmep.ca" \
  -d '{"title":"Post-Restart Create","priority":"high"}' | jq -r '.id')

# Status change -> status_changed
curl -s -X PATCH "http://localhost:3000/api/tasks/$TASK_ID/status" \
  -H "Content-Type: application/json" \
  -H "X-User-Email: admin@edenmep.ca" \
  -d '{"status":"in_progress"}' >/dev/null

# Add comment -> comment_added
curl -s -X POST "http://localhost:3000/api/tasks/$TASK_ID/comments" \
  -H "Content-Type: application/json" \
  -H "X-User-Email: admin@edenmep.ca" \
  -d '{"body":"Post-restart comment smoke"}' >/dev/null

# Verify last events
psql "$DATABASE_URL" -c "
  select type,
         substring(project_id::text,1,8)||'...' as proj,
         substring(task_id::text,1,8)||'...' as task,
         payload->>'title' as title,
         payload->>'new_status' as new_status,
         payload->>'comment_preview' as preview,
         to_char(created_at,'HH24:MI:SS') as t
  from notifications
  where created_at > now() - interval '10 minutes'
  order by id desc
  limit 10;
"
```

Success check:

* Health endpoint returns JSON.
* You see three fresh rows: `task_created`, `status_changed`, `comment_added` with correct UUIDs and payloads.
* No “column is bigint but expression is uuid” warnings in server logs.

Next: wait for user

—
Micro-lesson: events are **append-only facts**. Keep them small and typed (`::uuid`, `::jsonb`). Consumers (email digests, overdue reminders) read the stream; producers (your endpoints) never need to change again.
