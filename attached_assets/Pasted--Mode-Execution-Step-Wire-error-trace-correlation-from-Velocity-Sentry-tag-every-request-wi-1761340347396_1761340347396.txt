[Mode: Execution]

Step: Wire error & trace correlation from Velocity → Sentry: tag every request with its route + transaction, capture 5xx with rich tags, and add a “View in Sentry” deep link per route on /velocity. (Layer: Velocity → Correlation)

Why it matters: You can jump from a red row or regression straight to the exact errors/traces for that route and build.

Inputs needed:

Backend server.js (Sentry already installed)

Frontend apps/coordination_ui/src/pages/Velocity.jsx

Secrets: SENTRY_ORG_SLUG, SENTRY_PROJECT_SLUG, SENTRY_ENV (and you already have RELEASE_SHA, BUILD_TIME)

Command:

Backend — tag transactions and capture 5xx with route metadata

// server.js (near Sentry.init and middleware wiring)
const Sentry = require("@sentry/node");

// Ensure request + tracing handlers are registered early
app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

// Helper to get a stable route key (same as Metrics Core)
function routeKey(req) {
  return `${req.method} ${req.route?.path || req.path}`;
}

// Augment your existing timing middleware:
app.use((req, res, next) => {
  // name the Sentry transaction by route for better grouping
  const tx = Sentry.getCurrentHub().getScope()?.getTransaction?.();
  if (tx) tx.setName(routeKey(req));

  // add per-request tags early
  Sentry.setTag("route", req.route?.path || req.path);
  Sentry.setTag("method", req.method);
  if (process.env.RELEASE_SHA) Sentry.setTag("release", process.env.RELEASE_SHA);
  if (process.env.BUILD_TIME) Sentry.setTag("build_time", process.env.BUILD_TIME);

  const start = process.hrtime.bigint();
  res.on("finish", () => {
    const ms = Number(process.hrtime.bigint() - start) / 1e6;

    // add outcome tags on the active scope for breadcrumbs
    Sentry.setTag("status_code", res.statusCode);
    Sentry.setTag("duration_ms", Math.round(ms));

    // If a 5xx slipped through without throwing, report it explicitly
    if (res.statusCode >= 500) {
      Sentry.captureMessage("HTTP 5xx response", {
        level: "error",
        tags: {
          route: req.route?.path || req.path,
          method: req.method,
          status_code: res.statusCode,
          duration_ms: Math.round(ms),
        },
      });
    }
  });
  next();
});

// Keep Sentry error handler AFTER routes
app.use(Sentry.Handlers.errorHandler());


Backend — add a tiny helper to generate a Sentry deep link for a route

// server.js (after other /ops/* endpoints)
app.get("/ops/sentry-link", (req, res) => {
  const org = process.env.SENTRY_ORG_SLUG;
  const project = process.env.SENTRY_PROJECT_SLUG; // project slug
  const env = process.env.SENTRY_ENV || process.env.NODE_ENV || "dev";
  const route = req.query.route;
  if (!org || !project || !route) return res.status(400).json({ error: "missing org/project/route" });

  // Discover search that filters recent errors for this route & env (last 1h)
  const query = encodeURIComponent(`event.type:error environment:${env} route:"${route}"`);
  const name = encodeURIComponent(`Velocity: ${route}`);
  const url = `https://sentry.io/organizations/${org}/discover/results/?name=${name}&field=timestamp&field=message&field=release&field=trace&field=transaction&query=${query}&project=${project}&statsPeriod=1h`;
  res.json({ url });
});


Frontend — add a “Sentry” action per row on Velocity to open the deep link

// apps/coordination_ui/src/pages/Velocity.jsx
-            <tr>
+            <tr>
               {header("Route", "route")}
               {header("RPS (1m)", "rps")}
               {header("p50 ms (1m)", "p50_ms")}
               {header("p95 ms (1m)", "p95_ms")}
               {header("Error % (1m)", "err_rate")}
               {header("Samples (1m)", "count")}
               <th className="px-3 py-2">p95 (5m)</th>
               <th className="px-3 py-2">RPS (5m)</th>
               {header("Regress % (p95)", "regress_pct")}
+              <th className="px-3 py-2">Trace</th>
             </tr>
...
-                </td>
+                </td>
                 <td className="px-3 py-1">
                   <Sparkline points={r.trend} accessor={(b)=>b?.rps} title={`RPS (5m) ${r.route}`} />
                 </td>
                 <td className="px-3 py-2">
                   {Number.isFinite(r.regress_pct)
                     ? (<span className={`inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs
                         ${r.is_regress ? "bg-red-100 text-red-700 border border-red-200" : "bg-gray-100 text-gray-700 border border-gray-200"}`}>
                         {r.is_regress ? "↑ regress" : "—"} {r.is_regress ? `${r.regress_pct}%` : ""}
                       </span>)
                     : "—"}
                 </td>
+                <td className="px-3 py-2">
+                  <button
+                    className="px-2 py-1 rounded-md border hover:bg-gray-50"
+                    onClick={async () => {
+                      try {
+                        const res = await fetch(`/ops/sentry-link?route=${encodeURIComponent(r.route)}`, { cache: "no-store" });
+                        const j = await res.json();
+                        if (j?.url) window.open(j.url, "_blank", "noopener,noreferrer");
+                      } catch {}
+                    }}
+                    title="Open Sentry filtered to this route (last 1h)"
+                  >
+                    Sentry →
+                  </button>
+                </td>
               </tr>


Secrets — set once

SENTRY_ORG_SLUG=<your_org_slug>

SENTRY_PROJECT_SLUG=<your_project_slug>

SENTRY_ENV=prod (or staging/dev to match your setup)

Success check:

Hit a route that returns a 500 (or temporarily add a throw new Error("test")).

Go to /velocity; the row should show elevated error% or regression.

Click Sentry → on that row; a new tab opens Sentry Discover filtered to environment and route:"<METHOD /path>", last 1h.

Event page shows tags: route, method, status_code, release, build_time, with the transaction named like GET /api/whatever.

Next: wait for user.