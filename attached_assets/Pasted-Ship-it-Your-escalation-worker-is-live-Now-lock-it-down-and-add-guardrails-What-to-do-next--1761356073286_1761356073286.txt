Ship it. Your escalation worker is live. Now lock it down and add guardrails.

## What to do next (priority order)

### 0) Layer + stage

* **Ops layer — harden & observe.**
* **Backend layer — indexes & idempotency.**
* **RBAC layer — lock endpoints.**

### 1) Safety limits

* Cap escalation: `MAX_ESC_LEVEL=7`.
* Snooze window: `ESC_SNOOZE_MIN=30` after each escalation.
* Maintenance window: `ESC_PAUSE_CRON` (e.g., nights/weekends).
* Dry-run switch: `ESC_DRY_RUN=true` for hotfixes.

### 2) Idempotency + de-dupe

* Compose an event key: `hash(incident_key|level)`; store in `escalation_events(unique_hash)`.
* On tick, skip if hash exists.
* Slack de-dupe: include `X-Dedup-Key` header or key in payload.

### 3) Secure the test endpoint

* Restrict `POST /ops/escalation/tick` to admins only.
* Add HMAC: header `X-Signature: HMAC_SHA256(body, SECRET)`.
* Rate-limit: 10/min.

### 4) Indices and computed scheduling

Add `next_due_at` to avoid scanning:

```sql
ALTER TABLE incidents
  ADD COLUMN next_due_at timestamptz
  GENERATED ALWAYS AS (
    CASE
      WHEN acknowledged_at IS NOT NULL THEN NULL
      ELSE first_seen
           + (CASE severity WHEN 'critical' THEN ESC_CRIT_ACK_MIN ELSE ESC_WARN_ACK_MIN END || ' minutes')::interval
           * (escalation_level + 1)
    END
  ) STORED;

CREATE INDEX ON incidents (acknowledged_at);
CREATE INDEX ON incidents (severity, escalation_level);
CREATE INDEX ON incidents (next_due_at) WHERE acknowledged_at IS NULL;
```

Worker query becomes “`WHERE acknowledged_at IS NULL AND now() >= next_due_at`”.

### 5) Observability

Emit counters:

* `escalation_tick_ms`, `escalations_count`, `skipped_idempotent`, `slack_send_failures`, `queue_lag_ms`.
  Dash alerts:
* Any tick > 2× `ESC_TICK_MS`.
* Slack failures > 0 for 5 min.
* L≥5 incidents count > threshold.

### 6) Config sanity

* Verify `APP_BASE_URL` across envs.
* Per-route webhooks: validate at boot; fall back to global.
* Timezone: store UTC only. Avoid DST drift.

### 7) Tests to add

* Clock-skew ±120s.
* SLA change mid-flight (migrate `next_due_at`).
* Worker restart replays once only (idempotency).
* Snooze window honored.
* Pause cron respected.

### 8) Runbook (one page)

* How to pause (`ESCALATION_WORKER_ENABLED=false`).
* How to drain stuck incidents (ack or force-lower level).
* Slack webhook rotation steps.
* Query to audit last 24h:

```sql
SELECT incident_key, escalation_level, escalated_at
FROM escalation_events
WHERE created_at > now() - interval '24 hours'
ORDER BY created_at DESC;
```

### 9) Rollout

* Feature flag `escalation_v1=true`.
* Canary 10% routes for 24h.
* Enable global after clean canary.

### 10) Notion updates (Track A)

* Add “Incident Escalation v1” spec link, runbook, and SLA table.
* Add checklist items: idempotency, indices, RBAC on ops endpoints, alert thresholds.
* Mark milestone: **Ops>Escalation v1: Production**.

**Suggestion:** add a backfill job `ops/escalation/recalc` that only recomputes `next_due_at` after SLA changes. This prevents silent drift.
